---
title: "Proportional Loading"
author: "Jonathan Bourne"
date: "14 February 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

This script is for the PhD chapter/paper on proportional grid loading.

The goal of this paper is to compare real and proportional line limits and see what affect this has on cascading failures in the power-grid during attack.

Open data on powergrid modelling
https://www.sciencedirect.com/science/article/pii/S2352484716300877#f000005


There are 4 lines which are overloaded from the beginning they are given artificial line limits to maintain grid integrity

#Setup Block

```{r}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "zoo", "stringr","xtable", "geomnet", "rlang", "animation", "caret", "modelr", "yardstick", "sf", "rgdal", "RColorBrewer", "geosphere")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)


sapply(packages, library, character.only = TRUE)


lapply(packages, library, character.only = TRUE)
library(PowerGridNetworking)

select <- dplyr::select

#Set up file system to read the correct folders this switches between aws and windows mode

basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
datafile <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ETYSAppendixB"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Proportional Line Limits" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
Tariff <- file.path(basewd,"Tariff and Transport")
PLwd <- "/media/jonno/Seagate Expansion Drive/ProportionalLoading"
Saved_Sims <- file.path(PLwd, "Saved_Sims")
#Deletion_Order_Folder <-  file.path(PLwd, "DeletionOrder") #Only one of the deletion order folders is needed. Either Nodes or Edges
Deletion_Order_Folder <- file.path(PLwd, "DeletionOrder_Nodes")
StratAttackWd <- "/media/jonno/Seagate Expansion Drive/ProportionalLoading/StratAttack"

#Load necessary datasets and great the base powergrid network
source(file.path("/home/jonno/ProportionalLoading", "CreateGBase.R"))

#Load some other useful functions
list.files("/home/jonno/Useful_PhD__R_Functions", pattern = ".R", full.names = T) %>%
  walk(~source(.x))

#FOr NetSci
#FiguresFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/NetSci2018 Poster/Figures"
```

#Create the Attack Orders
```{r}
#Set the path to a large enough storage
setwd(PLwd)

#Ensure there is powerflow
g <- PowerFlow(gbase, "GLLE")

g %>%
  simplify(., remove.multiple = T, remove.loops = T) %>% 
    plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label=NA)

NetworkStats(g) %>%
  xtable() %>% print(type = "latex", file = file.path(FiguresFolder, "NetworkStats.txt"))

AttackRounds <- 1000

#Create a reproducible attack order
seed<- 1589
filename <- "DeleteOrders100.rds"
if(file.exists(filename)){
  DeleteOrders <- readRDS(filename)
} else {
set.seed(seed)
DeleteOrders <- MultiAttackOrder(gbase, 100)  
saveRDS(DeleteOrders, filename)
}

```

#Set alpha colour gradient
```{r}
  AlphaGrad <- scale_colour_gradientn(colors = c("red",   "limegreen"),
                          breaks = c(1,2,7,20,50),
                          trans = "log",
                          values = scales::rescale((c(0, 6, 7, 20, 50))),
                          name = expression(alpha*" level")) #"Alpha value"
```

#Comparison of line limit methods

This section compares artificial line limits created using a variety of metrics

```{r}

alpha_levels <- seq(1, 7, 0.05) #c(1, 1.05, 1.1, 1.2, 1.5, 2, 3, 5, 6,7)
#alpha_levels <- c(1, 1.05, 1.1, 1.2, 1.5, 2, 3, 5,6,7,8,9,10)

EdgeAttr <- get.edge.attribute(g) %>% names %>% 
  map(~{
    data_frame(temp = get.edge.attribute(g, name = .x)) %>%
      set_names(.x)
  }) %>% bind_cols() %>%
   filter(Link.Limit!=1e5, Voltage!=0
         )

EdgeAttr2  <- alpha_levels %>% map(~{

  Proportional_Load(g, .x) %>% 
    get.edge.attribute(., "Link.Limit") %>%
    data_frame(temp = .) %>%
    set_names(paste0("alpha_value_", .x*100))
  
}
) %>% bind_cols() %>%
  filter(get.edge.attribute(g, "Voltage")!=0,
          get.edge.attribute(g, "Link.Limit")!= 1e5)
         
#The results
#This allows us to compare performance of PL edges with the modelled ones.
Limit_Method_RMSE <- EdgeAttr2 %>%
  map_df(~{
   c(postResample(.x, EdgeAttr$Link.Limit) , 
  mean(abs((EdgeAttr$Link.Limit - .x)/EdgeAttr$Link.Limit))) %>%
  matrix %>%
  t %>%
  data.frame() %>% set_names(names(postResample(EdgeAttr$Link.Limit, .x)), "MAPE" )
  
  }) %>%
  mutate(type = names(EdgeAttr2),
         method =  str_split(type, '_(?=[^_]+$)') %>% 
           transpose() %>% 
           .[[1]] %>% 
           unlist,
         Level = str_split(type, '_(?=[^_]+$)') %>% 
           transpose() %>% 
           .[[2]] %>% 
           unlist) %>%
  #This bit converts the Level to numeric. Useful when Only Alpha is being analysed
  mutate(Level = as.numeric(Level)/100)


rm(EdgeAttr); rm(EdgeAttr2)
```

#Load level plot
```{r}
edges <- g %>% as_data_frame %>%
   mutate(alpha = Link.Limit/abs(PowerFlow),
          LoadLevel = 1/alpha,
          PercLL = percent_rank(LoadLevel),
          PercLinkLimit = percent_rank(Link.Limit),
          PercFlow = percent_rank(abs(PowerFlow)))


LabelNames <- round(1/c(-.1, 0, .1,.2,.3,.4,.5,.6,.7,.8,.9,1), 2)
LabelNames[1:2] <- c("", ">10") 

#Uses only Alpha which is much easier for people to understand
 edges %>%
   #filter(alpha>1)%>%
   filter(is.finite(alpha), Link.Limit!= 100000) %>%
   ggplot(aes(x = LoadLevel)) + 
   geom_histogram(bins = 10, aes(y = (..count..)/sum(..count..)))+ #remove the fill to make it black again , fill = rev(AccBarCol[-c(1:2)])
  scale_y_continuous(labels = scales::percent, breaks = seq(0,.5, by= 0.05)) +
   labs(x = expression(alpha*" level"), 
        y ="Percentage of total lines", 
        title = expression("Distribution of "*alpha*" using real line limits under initial conditions")) +
   scale_x_reverse(breaks = seq(1,-.1, by=-0.1), labels= rev(LabelNames))
 ggsave(file.path(FiguresFolder,"LoadLevel.pdf"))

median(abs(edges$Link.Limit/edges$PowerFlow))
mean(abs(edges$Link.Limit/edges$PowerFlow))
```

#Generate Attack data

##Real line limits

```{r}

setwd(Saved_Sims)

folder <- "Real_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```


##Topological
Previously called Infinite limits

```{r}

setwd(Saved_Sims)

folder <- "Test2" #"Topological"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = F)

```


##PL limits

This function saves networks.
Should the function should be changed so that it can handle edges as well as nodes.

```{r}

#The vector of alpha values to be tested
alpha_vector <- c(1.05, 1.1, 1.2, 1.5, 2, 3, 5, 7, 10, 15, 20, 50)
setwd(Saved_Sims)
#alpha_vector <- c(35)

#Create the simulations for each of the alpha avalues using 100 simulations for each
alpha_vector %>% walk(~{
  gProp <- Proportional_Load(g, alpha = .x)
  
  folder <- paste0("alpha_value_",  .x*100)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
  SaveMultiAttacks(gProp, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)
  
}
  
)
  
```


##Modelled limits


```{r}
table(ntile(ModelInputVars$Voltage,3),ntile(ModelInputVars$Link.Limit,3))

table(ntile(ModelInputVars$Voltage,3),ntile(ModelInputVars$Length,3))

table(ntile(ModelInputVars$Link.Limit,4),ntile(ModelInputVars$Elec_Centrality,4))

```


```{r}

#Set seed and create model input variables
set.seed(1)
ModelInputVars <- g %>% as_data_frame %>%
  mutate(absPF = abs(PowerFlow),
         Voltage = as.factor(Voltage)) %>%
  select(Link.Limit, Voltage, absPF, Link, Length)

ModelInputVars <- g %>% as_data_frame %>% left_join(.,  ElectricalCentrality(g)$EdgeEC %>% 
                rename(Elec_Centrality = ElectricalCentrality, Link = Edgename)) %>%
  mutate(absPF = abs(PowerFlow),
         Voltage = as.factor(Voltage),
         Centrality =log10(edge_betweenness(g)+1),
         LengthQuart = ntile(Length, 4),
         absPFQuart = ntile(absPF, 4),
         LogLink.Limit = log10(Link.Limit)) 

#generate k=10 crossfold validated model
models <- ModelInputVars %>%
  filter(Link.Limit != 1e5) %>%
  crossv_kfold(k = 10) %>%
  #The log limit of the model is used to make it more normally distributed
  mutate(model = map(train, ~ lm(LogLink.Limit ~ Voltage + Elec_Centrality, data = .)))

#create predictions for each edge in the network
predictions <- models %>%
  unnest(map2(model, test, ~ augment(.x, newdata = .y))) %>%
  mutate(.fitted = 10^.fitted)

 metrics(predictions , Link.Limit, .fitted);  mean(abs(predictions$.fitted-predictions$Link.Limit)/predictions$Link.Limit)

#Look at coefficiients
ModStats <- models %>%
  unnest(map(model, ~ tidy(.x))) %>%
   select(.id, term, estimate) %>%
   spread(key = term, value = estimate) %>% 
   select(-.id) 
   
bind_rows(ModStats %>% summarise_all(mean) %>% mutate(type = "mean"),
              ModStats %>% summarise_all(sd) %>% mutate(type = "sd")) %>%
     select(type, everything()) %>%
   #  mutate_if(is.numeric, signif, digits = 2) %>%
xtable(.,  
       caption = "Mean model coefficients and standard deviation across 10-fold cross-validation", 
       label = "tab:ModCoeffs") %>%
   print(type = "latex", file = file.path(FiguresFolder, "ModCoeffs.txt"))
 
#Create new edge limits using the predictions
NewEdges <- tibble(Link = get.edge.attribute(g, "Link") ) %>%
  left_join(., predictions) %>%
  mutate(.fitted = ifelse(is.na(.fitted), 1e5, .fitted))

LinModLims <- set_edge_attr(g, "Link.Limit", value = NewEdges$.fitted)

#Generate simulations
setwd(Saved_Sims)

folder <- "Linear_Model_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(LinModLims, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```

#Extracting stats

Extracting stats is slow this extracts the stats and saves them as a file.

```{r}

ExtractAttackStats(Saved_Sims, file.path(PLwd, "SummaryData"))

#Load the saved files
AttackRoundData <- list.files(path = file.path(PLwd,"SummaryData"), 
                              pattern = ".rds", 
                              full.names = TRUE) %>%
   map_df(~read_rds(.x))



```

#Construct attack summaries

Plots simple graphs from summary data

```{r}

SummaryofGC<- AttackRoundData %>%
  SummariseMultiAttack%>%
  mutate(PercNum = NodesAttacked/958,
         alpha = sub("alpha_value_", "", alpha) %>% sub("_", " ", .))


PNodeDens <-  AttackRoundData %>%
  mutate(PercNum = round(NodesAttacked*100/958),
            LoadDrop = (first(GridLoading)-GridLoading)/first(GridLoading))


# test2 <- PNodeDens  %>%
#   select(GCfract, Blackout, alpha, PercNum) %>%
#   gather(., key="Type", value = "value",GCfract, Blackout) %>%
#   mutate(Type = ifelse(Type == "GCfract","Giant componant size reduction", "Blackout size"))
#   
# 
#  test2   %>%
#      filter(is.finite(value)) %>%
#   mutate(  PercAttacked= fct_rev(as_factor(paste0(PercNum, "%"))))  %>%
#   ggplot(aes(y = PercAttacked)) +
#   geom_density_ridges(aes(x = value, fill = alpha), alpha = 0.5)  + 
#   scale_x_continuous(labels=scales::percent)  +
#       facet_grid(~Type) +
#   labs(x = "Performance drop", y = "Percent of elements attacked",
#        title = "Change in the performance distribution as number of attacks increase") 


 NodeCollapse <- rbind(SummaryofGC %>%
  select(PercNum, mean, alpha, GC05, GC95, sd) %>% mutate(type = "Giant componant size reduction"),
SummaryofGC %>% 
  select(PercNum, mPGfract, alpha, PG05, PG95, sdPGfract) %>% 
  mutate(type = "Blackout size") %>%
  rename(mean = mPGfract, GC05 = PG05, GC95 = PG95, sd = sdPGfract)
) %>% mutate(Target = "Node") %>%
   filter(alpha != "Constant 105", alpha != "Constant Volt_105" )

 NodeCollapse2<- NodeCollapse %>%
   filter(alpha != "Real Limits", alpha != "Linear Model_Limits", alpha != "Topological") %>%
   mutate(alpha = ifelse(alpha == "Topological", "Inf", alpha),
          alpha = as.numeric(alpha)/100) %>%
   arrange(alpha)
 
AlphaCollapse <- NodeCollapse2 %>%
       filter(is.finite(sd))#need to remove infinte values 

RealCollapse <- NodeCollapse %>% 
               filter(alpha == "Real Limits",is.finite(sd))#need to remove infinte values 
   
ModelledCollapse <- NodeCollapse %>% 
               filter(alpha == "Linear Model_Limits",is.finite(sd))#need to remove infinte values 

TopoCollapse <- NodeCollapse %>% 
               filter(alpha == "Topological",is.finite(sd))#need to remove infinte values 


NameOrder <- tibble(name = c("Real", "Modelled", "Topological"), Colour = c("black", "blue", "grey50")) %>% arrange(name)

AlphaCollapse %>% #need to remove infinte values 
  ggplot(aes(x = PercNum, y =  mean, group = alpha)) + 
  geom_line(aes(colour = as.numeric(alpha)), show.legend = TRUE) +  
  AlphaGrad +
  geom_line(data = RealCollapse, aes(fill = 'Real'), color = 'black', linetype ="longdash") +
  geom_line(data = ModelledCollapse, aes(fill = 'Modelled'), color = 'blue', linetype ="longdash") +
  geom_line(data = TopoCollapse, aes(fill = 'Topological'), color = 'grey50', linetype ="longdash") +
  scale_fill_manual("Line Limit", values=c(1, 1, 1),
        guide=guide_legend(override.aes = list(colour=NameOrder$Colour))) +
  facet_grid(~type) +
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
  coord_cartesian(x = c(0,0.5)) +
  labs(title = "Change in Giant componant and Blackout size as nodes are attacked" , 
       x = "Percent of elements attacked", 
       y = "Performance drop")
 
 ggsave(file.path(FiguresFolder,"GCandBlackoutChange.pdf"))


 AlphaCollapse %>% #need to remove infinte values 
  ggplot(aes(x = PercNum, y =  sd, group = alpha)) + 
  geom_line(aes(colour = as.numeric(alpha)), show.legend = TRUE) +  
  AlphaGrad +
  geom_line(data = RealCollapse, aes(fill = 'Real'), color = 'black', linetype ="longdash") +
  geom_line(data = ModelledCollapse, aes(fill = 'Modelled'), color = 'blue', linetype ="twodash")  +
  geom_line(data = TopoCollapse, aes(fill = 'Topological'), color = 'grey50', linetype ="longdash") +
  scale_fill_manual("Line Limit", values=c(1, 1, 1),
        guide=guide_legend(override.aes = list(colour=NameOrder$Colour))) +
  facet_grid(~type) +
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
  coord_cartesian(x = c(0,0.5))  +
  labs(title = "Standard deviation of damage across all simulations" , x = "Percent of elements attacked", y = "Standard deviation of damage")
 ggsave(file.path(FiguresFolder,"SDchange.pdf"))
 
 
 NodeCollapse3 <- bind_rows(AlphaCollapse %>% mutate(alpha = as.character(alpha)), ModelledCollapse) %>%
   left_join(., select(RealCollapse, PercNum, Realmean = mean, Realsd = sd , type) , by = c("PercNum", "type"))
   
 Inputs <- expand.grid(unique(NodeCollapse3$alpha), unique(NodeCollapse3$type)) 
  
MeanRMSE <- map2_df(.x = Inputs$Var1, .y = Inputs$Var2,~{
    NodeCollapse3 %>%
      filter(alpha == .x, type == .y) %>%
     metrics(Realmean, mean) %>%
     mutate(alpha = .x, type = .y)
  } ) %>%
  select(-rsq) %>%
  spread(key = type, value = rmse)

Meansd <- map2_df(.x = Inputs$Var1, .y = Inputs$Var2,~{
    NodeCollapse3 %>%
      filter(alpha == .x, type == .y) %>%
     metrics(Realsd, sd) %>%
     mutate(alpha = .x, type = .y)
  } ) %>%
  select(-rsq) %>%
  spread(key = type, value = rmse)

 
```


#Deletion similarity

##Round Deleted

Get the round number that an edge was deleted.

```{r}

FolderVect <- list.files(path = Saved_Sims) #folder where all the alpha FOLDERS are
FileVect <- list.files(path = Deletion_Order_Folder) %>% gsub(".rds", "",.) #folder where all the deletion order FILES are
new.type <- FolderVect[!(FolderVect %in% FileVect)] #The FOLDERS that are not present as FILES

if(length(new.type)>0){
file.path(Saved_Sims, new.type) %>%
  walk( ~{
    print(.x) #print name of folder where deletion order will be calculated
    
  Removeddf <- list.files(path = .x, full.names = TRUE) %>% #list the different network of network rds files present
    map_df(~{
        file <- .x
        print(file)
        read_rds(file) %>%
          RoundTypeRemoved (.)  %>%
          mutate(Sim = gsub(".rds", "",file) %>% basename)
      }
    ) %>%
    group_by(Sim) %>%
    mutate(RoundRemoved = ifelse(is.na(RoundRemoved), max(RoundRemoved), RoundRemoved),
         alpha = basename(.x)) %>% 
    ungroup

  Removeddf %>%
        write_rds(x = ., paste0(file.path(Deletion_Order_Folder,basename(.x)), ".rds"))
  }
  )

} 
  
AllRemovedNodes <- list.files(Deletion_Order_Folder, full.names = TRUE) %>%
  map_df(~read_rds(.x))

```

##Number of round per line-type
```{r}

#Check number of rounds
 NumberofRounds <- AllRemovedNodes %>%
  group_by(Sim, alpha, type) %>%
  summarise(counts = max(RoundRemoved, na.rm = T)) %>%
   ungroup %>% mutate( RemovalType = "Rounds")

 
 #Plot the number of rounds
NumberofRounds %>%
  filter(type== "Node") %>%
  CleanNames(., "alpha", AlphaOrder) %>%
  mutate( alpha = ifelse(alpha== "Topological","Inf", alpha),
         alpha = gsub("alpha_value_", "", alpha),
         alpha = as.numeric(alpha)/100
) %>%
  ggplot(aes(x = alpha2, y = rounds)) + geom_boxplot()+
    theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1)) 

test2 <- AllRemovedEdges %>%
  group_by(Sim, alpha) %>%
  mutate(decile = ntile(RoundRemoved, 10))

test <- AllRemovedNodes %>%
  group_by(type, alpha, Sim, RemovalType) %>%
  summarise(counts = n()) %>%
  spread(key = RemovalType, value = counts) %>%
  ungroup
  
test %>%
  filter(alpha !="Topological") %>%
  select(Islanded:Targeted) %>%
  cor

 AllRemovedNodes %>%
  group_by(type, alpha, Sim, RemovalType) %>%
  summarise(counts = n()) %>%
 #bind_rows(., NumberofRounds) %>%
     filter(type == "Node") %>%
   ggplot(aes(x = alpha, y = counts)) + geom_boxplot() + facet_wrap(type~RemovalType)+
    theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1)) 

 
  AllRemovedNodes %>%
  group_by(type, alpha, Sim, RemovalType) %>%
  summarise(counts = n()) %>%
    filter(type == "Node", RemovalType !="Islanded") %>%
     spread(key = RemovalType, value = counts) %>%
    rename(Rounds = Targeted) %>%
ggplot(aes(x = Overloaded, y = Rounds, colour = alpha))  + geom_point() +
    ggtitle("Number of Rounds vs number of overloaded nodes")
 
```

##Islanding per round
```{r}
 LossFractionByRound <- AllRemovedNodes %>%
  group_by(Sim, alpha, type, RoundRemoved, RemovalType) %>%
  summarise(counts = n()) %>%
  group_by(Sim, alpha, type, RemovalType) %>%
  mutate(cumsum = cumsum(counts)) %>%
  group_by(alpha, type, RoundRemoved, RemovalType) %>%
  summarise(mean = mean(counts),
            median = median(counts),
            sd = sd(counts),
            cummean = mean(cumsum),
            cummedian = median(cumsum),
            cumsd = sd(cumsum)) %>%
  left_join(tibble(type = c("Edge", "Node"), 
                    tot = c(ecount(gbase), vcount(gbase)))
            ) %>%
  group_by(alpha, type, RemovalType) %>%
  mutate( test = cumsum(median),
          testfrac = test/tot,
    cummeanfrac = cummean/tot,
            cummedianfrac = cummedian/tot)

LossFractionByRound %>%
  filter(type == "Node", RemovalType != "Targeted") %>%
  ggplot(aes(x = RoundRemoved, y = cummean, group = alpha, colour = alpha)) + geom_line() + 
  facet_wrap(~RemovalType)
  
Loss2 <- AllRemovedNodes %>%
  group_by(Sim, alpha, type, RoundRemoved, RemovalType) %>%
  summarise(counts = n()) %>%
  group_by(Sim, alpha, type, RemovalType) %>%
  mutate(cumsum = cumsum(counts)) 

Loss2 %>%
  filter(type == "Node", alpha == "alpha_value_300", RemovalType != "Targeted") %>%
  ggplot(aes(x = RoundRemoved, y = cumsum, group = Sim, colour = alpha)) + geom_line() + 
  facet_wrap(.~RemovalType, scales = "free_y")

Loss3 <- Loss2 %>%
  group_by(Sim, type, alpha, RemovalType) %>%
  summarise(cumsum = max(cumsum)) %>%
  spread(key = RemovalType, value = cumsum)

#Strong negative corellation with between Targeted and overload for edge removal, but also for Islanded... What?
Loss3 %>%
  filter(type == "Node", alpha == "Real_Limits") %>%
  ggplot(aes(x = Islanded, y = Overloaded)) +
  geom_point()

   Loss3 %>%
 # filter(type == "Node", alpha == "Real_Limits") %>%
     group_by(alpha, type) %>%
     summarise(corTargOver = cor(Targeted, Overloaded, use =  "pairwise.complete.obs"),
               corTargIsl = cor(Targeted, Islanded, use =  "pairwise.complete.obs"),
               corOverIsl = cor(Overloaded, Islanded, use =  "pairwise.complete.obs")) %>%
     arrange(type)
  
```


##Plot Correlation

This needs to be edited to account for the changed in the RoundRemoved function that differentiate between Overload/Targeted or Unknown removal types. 

```{r}
# testList <- file.path("/media/jonno/Seagate Expansion Drive/ProportionalLoading/Saved_Sims/Linear_Model_Limits",
#                   "Simulation_ID_1.rds") %>% 
#   read_rds

#Get only the real limits
RealPreCor  <- AllRemovedEdges %>%
  filter(alpha == "Real_Limits") %>%
  select(-alpha)

#Add the real limits onto the other nodes to allow direct comparison
#Filter out the NA values
PreCorRemoved  <- AllRemovedEdges %>%
  filter(alpha != "Real_Limits") %>%
  left_join(., RealPreCor, by = c("Edges", "Sim")) %>%
  mutate(RoundRemoved.x = ifelse(TargetNode.x, NA, RoundRemoved.x ),
         RoundRemoved.y = ifelse(TargetNode.y, NA, RoundRemoved.y ))


AllCombos <- PreCorRemoved  %>% distinct(alpha, Sim)

#Cycle through all the combinations of alpha and sim to get the corellation for all
  test <- map2_df(.x = AllCombos$Sim, .y = AllCombos$alpha, ~{
   
    temp <- PreCorRemoved %>%
    filter(Sim == .x, alpha == .y, complete.cases(.))
      cor(temp$RoundRemoved.x, temp$RoundRemoved.y, method = "kendall") %>%
        tibble(Sim = .x, alpha = .y, cor =.)
    
  })

#"Infinite Limits"
AlphaOrder <- c("alpha value 1","alpha value 1.05","alpha value 1.1","alpha value 1.2","alpha value 1.5","alpha value 2" ,"alpha value 3","alpha value 5","alpha value 6","alpha value 7","alpha value 10","alpha value 15","alpha value 20","alpha value 50","Topological" ,"Linear Model Limits")  

#Pre process data for plot
 AlphavsCor <- test %>%  CleanNames(., "alpha", AlphaOrder) %>%
  mutate( alpha = ifelse(alpha== "Topological","Inf", alpha),
         alpha = gsub("alpha_value_", "", alpha),
         alpha = as.numeric(alpha)/100
) 
 
 #Make temporary plot
 #This is used so that the blue can be added on for the linear line limits
 TempPlot <- AlphavsCor %>%
  ggplot(aes(x = alpha2, y = cor, fill = alpha)) + geom_boxplot()+
  scale_fill_gradientn(colors = c("red",   "limegreen"),
                          breaks = c(1,2,7,20,50),
                          trans = "log",
                          values = scales::rescale((c(0, 6, 7, 20, 50))))

#Extract the colour codes from the ggplot object.
AccBuild <- ggplot_build(TempPlot)
AccBarCol <- c(unique(AccBuild$data[[1]][[1]]), "blue")
names(AccBarCol) <-AlphavsCor$alpha2 %>%  levels
rm(TempPlot)

AlphavsCor %>%
    ggplot(aes(x= alpha2, y = cor, fill = alpha2)) +
  geom_boxplot() +
    scale_fill_manual(values= AccBarCol) +
  scale_y_continuous( breaks = seq(0,1, by= 0.1)) +
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = expression(alpha*" level"), y ="Correlation with real line limits", title= "Node removal rank correlation against real limits")

ggsave(file.path(FiguresFolder, "CorBoxPlot.pdf"))

AlphavsCor %>% 
  group_by(alpha) %>%
  summarise(mean= mean(cor),
            median = median(cor),
            sd = sd(cor))


#Check the number of NA values
#Na values arethe nodes that were targeted for removal. They are therefore removed from the simulation
HowManyNAs <- PreCorRemoved %>%
  group_by(alpha, Sim) %>%
  summarise(counts = sum(is.na(RoundRemoved.x*RoundRemoved.y)))

HowManyNAs %>%
  ggplot(aes(x = as.factor(alpha), y = counts)) + geom_boxplot()


```

#Damage analysis
This can be expanded to look at different metrics
```{r}

BasePlot <- function(df){
#Sets up the plot for comparing different metrics, the metric of choice info is then added on
  df %>%
    ggplot(aes(x= alpha2, fill = alpha2)) +
    theme(legend.position = "none",  
        axis.text.x = element_text(angle = 45, hjust = 1))+
    scale_fill_manual(values= AccBarCol) + #requires the colours that have been previously calculated in the boxplot chunk
  scale_y_continuous( breaks = seq(0,1, by= 0.1))
  
  }

AccuracyAnalysis <- DamageComparison(AttackRoundData, "Blackout")

AccuracyAnalysis %>%
  select(-SimulationID,-alpha) %>%
  group_by(alpha2) %>%
  summarise_all(funs(mean, median))

AccPlot <- AccuracyAnalysis  %>% BasePlot

 AccPlot + geom_boxplot(aes(y = RMSE)) +
  labs(x = expression(alpha*" level"), 
       title = expression("RMSE against real line limits for all calculated "*alpha*" levels") )
ggsave(file.path(FiguresFolder, "RMSEChange.pdf"))

```


#Strategy difference

See the difference between strategies
##Different strategies 1 load level
```{r}
#The vector of alpha values to be tested
StratAttackVect <- CreateStrategyAttackDf(g)

alpha_vector <- c(1.05, 1.1,1.5, 2, 5,  10, 20, 50)

setwd(StratAttackWd)

#Create the simulations for each of the alpha avalues using 100 simulations for each
alpha_vector %>% walk(~{
    gProp <- Proportional_Load(g, alpha = .x)
    
    folder <- paste0("alpha_value_",  .x*100)
    #create folder if it doesn't already exist
    if(!file.exists(folder)){
      dir.create(folder)
    }
    
    SaveMultiAttacks(gProp, StratAttackVect, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)
    
  }
  
)

setwd(StratAttackWd)
folder <- "Real_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g,  StratAttackVect, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

setwd(StratAttackWd)
folder <- "Topological"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, StratAttackVect, folder, TotalAttackRounds = AttackRounds, CascadeMode = F)

setwd(StratAttackWd)
folder <- "Linear_Model_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(LinModLims, StratAttackVect, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```

##Plot differences

```{r}

RootFolder <- StratAttackWd

ExtractAttackStats(StratAttackWd, file.path(PLwd, "Attack_Strategy_SummaryData"))

AttackStratRoundData <- list.files(path = file.path(PLwd,"Attack_Strategy_SummaryData"), 
                              pattern = ".rds", 
                              full.names = TRUE) %>%
   map_df(~read_rds(.x)) %>%
  mutate(simulationID = case_when(
    simulationID == "1" ~"Degree" ,
    simulationID == "2" ~"EntDeg_LinkLimit",
    simulationID == "3" ~"EntDeg_PowerFlow",
    simulationID == "4" ~"Elec_Centrality",
    TRUE ~ "Centrality"
  ),
  alpha1 = alpha %>%
           str_replace_all(., "_", " ") %>%
           str_extract_all(., "([0-9])+")%>% as.numeric(.)/100,
alpha = alpha %>%
  str_replace_all(., "_", " ") %>%
  str_extract_all(., "([aA-zZ\\s])+", T) %>%
  paste0(., ifelse(is.na(alpha1), "", alpha1)),
  alpha = fct_relevel(alpha, "alpha value 5", after=2) %>%
  fct_relevel(., "alpha value 2", after=2) %>%
  fct_relevel(., "alpha value 1.5", after=2),
  PercNum = NodesAttacked/958) %>% 
  group_by(NodesAttacked, alpha) %>%
  mutate(rankblack = min_rank(-Blackout),
         rankGC = min_rank(GCfract)) %>%
  ungroup

AttackStratRoundData %>% #need to remove infinte values
  filter(alpha %in% c("alpha value 5", "Topological", "Linear Model Limits", "Real Limits")) %>%
  ggplot(aes(x = PercNum, y =  GCfract, colour = simulationID)) + 
  geom_line() +  
  #geom_line(data = RealCollapse, aes(fill = 'Real'), color = 'black') +
  #geom_line(data = ModelledCollapse, aes(fill = 'Modelled'), color = 'blue') +
  scale_fill_manual("Line Limit", values=c(1, 1)) +
  facet_wrap(~alpha) +
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
  coord_cartesian(x = c(0,0.3)) +
  labs(title = "Change in Blackout size as nodes are attacked using multiple strategies" , 
       x = "Percent of elements attacked", 
       y = "Performance drop",
       colour = "Attack Strategy")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggsave(file.path(FiguresFolder,"AttackStratDiff.pdf"))

test2 <-AttackStratRoundData %>%
  left_join(., 
            AttackStratRoundData %>%
  filter(alpha == "Real Limits") %>%
  select(NodesAttacked, simulationID, rankblack, rankGC), 
            by = c("NodesAttacked","simulationID")) %>% 
  ungroup %>%
         mutate(CorrectRank= rankblack.x==rankblack.y,
                rankdiff = rankblack.x-rankblack.y,
            r1 = as.factor(rankblack.x),
            r2= as.factor(rankblack.y)
    ) %>% ungroup

MapPairs <- expand.grid(unique(test2$simulationID),unique(test2$alpha) ) %>%
  as_tibble()

#calc error
test3 <- map2_df(.x= MapPairs$Var1, .y=MapPairs$Var2, ~{
  test2   %>%
    filter(alpha ==.y) %>%
    group_by(alpha) %>%
    mutate(acc = accuracy(., estimate = r1, truth =  r2) %>% pull(.estimate),
           AlphaRMSE = rmse(., estimate =rankblack.x, truth =  rankblack.y) %>% pull(.estimate)) %>%
    filter(simulationID ==.x) %>%
    group_by(simulationID, alpha) %>%
    summarise(RMSE = rmse(., estimate =rankblack.x, truth =  rankblack.y)%>% pull(.estimate), #measures for each sim ID for that class
              RSQ = rsq(., estimate =rankblack.x, truth =  rankblack.y) %>% pull(.estimate),
              CorrectRank = sum(CorrectRank, na.rm = T),
              CorrectPerc = n(),
              AlphaAccuracy = first(acc),
              AlphaRMSE = first(AlphaRMSE), #measures the whole class
              accuracy = accuracy(., estimate = r1, truth =  r2)%>% pull(.estimate)
             ) %>% 
    ungroup
          
  }) %>%
  filter(alpha!="Real Limits")
  

test2 %>%
  filter(alpha == "alpha value 5", simulationID=="Elec_Centrality") %>%
mutate(rankdiff = rankblack.x -rankblack.y) %>%
  ggplot(.,aes(x = NodesAttacked, y = rankdiff)) + geom_line() +
  labs(title= "Damage rank difference for Electrical centrality for alpha = 5\n rank difference of 0 means rank matches real results")


test3 %>%
  ggplot(., aes(x = simulationID, y = accuracy, fill = simulationID)) +
  geom_col() +
  facet_wrap(~alpha) +
  theme(axis.text.x = element_blank()) +
    labs(title= "The overall rank accuracy in terms of damage done\nby line limit setting and Attack strategy", 
       y = "Damage rank accuracy across entire simulation",
       x = "Attack Strategy"
      ) +
  guides(fill = guide_legend(title = "Attack Strategy"))

test <- test3 %>%
  mutate(alpha1 = alpha %>%
           str_replace_all(., "_", " ") %>%
           str_extract_all(., "([0-9\\.])+")%>% as.numeric(.))

TempPlot<- test %>%
  group_by(alpha, alpha1) %>%
  summarise(Accuracy = first(AlphaAccuracy)) %>% #AlphaAccuracy
  ggplot(aes(x= alpha, y = Accuracy, fill = alpha1)) +
  geom_col() +
  scale_fill_gradientn(colors = c("red",   "limegreen"),
                          breaks = c(1,2,7,20,50),
                          trans = "log",
                          values = scales::rescale((c(0, 6, 7, 20, 50))))


AccBuild <- ggplot_build(TempPlot)
AccBarCol <- c(unique(AccBuild$data[[1]][[1]]), "blue")
names(AccBarCol) <-test$alpha %>%  droplevels %>% levels
rm(TempPlot)

 test %>%
  group_by(alpha, alpha1) %>%
  summarise(Accuracy = first(AlphaRMSE)) %>% #AlphaAccuracy
   ungroup %>%
   mutate(alpha = factor(alpha, levels = AlphaOrder)) %>%
  ggplot(aes(x= alpha, y = Accuracy)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  labs(title= "The overall rank RMSE in terms of damage done by alpha level", 
       y = "Damage rank RMSE across entire simulation",
       x = "Line limit settings") #+
#  scale_fill_manual(values = AccBarCol, guide=FALSE) 
ggsave(file.path(FiguresFolder,"AttackStratRankPerf.pdf")) 
   
 #this looks like a better way of showing the data... but the simulations have different numbers of attacks so it may not be appropriate.
test %>%
  ggplot(aes(x= alpha, y = RMSE, fill = alpha)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  labs(title= "The overall rank RMSE in terms of damage done by alpha level", 
       y = "Damage rank RMSE across entire simulation",
       x = "Line limit settings") +
  scale_fill_manual(values = AccBarCol, guide=FALSE) 

test %>% select(alpha, accuracy, RMSE) %>%group_by(alpha) %>% summarise_all(funs(mean, median))
                                       
```


#Geo Points

##Load data

```{r}

library(geosphere)

points <- read_csv(file.path(basewd, "point.csv"))
  
coords2 <-  str_split_fixed(string = points$Lat.2, pattern = ",", n = 2)

points <- points %>%
  mutate(Lat.2 = coords2[,1] %>% as.numeric,
         Lon.2 = coords2[,2] %>% as.numeric)

points <- get.vertex.attribute(gbase, "name") %>% tibble(name = .) %>%
  left_join(., points, by = c("name" = "Edges")) %>%
  group_by(name) %>%
  mutate(counts = n()) %>%
  ungroup %>%
  group_by(name) %>%
  mutate(count = n()) %>%
  ungroup

```

```{r}
#Find all points with no coords
NApoints <-points %>%
  filter(is.na(Lon)) %>%
  pull(name)

#add coords to graph

pointsTemp <- points %>%
    filter(!grepl("Derby_South_132kV", SubstationName)) %>% #The node is definately not Derby south
  mutate(Lat = ifelse(!is.na(Lat.2), Lat.2, Lat),
         Lon = ifelse(!is.na(Lon.2), Lon.2, Lon)) 

g2 <- set.vertex.attribute(gbase, "Lat", value = pointsTemp$Lat) %>%
  set.vertex.attribute(., "Lon",value =  pointsTemp$Lon)

#find the average coordinates of the nodes with no coordinates based on thier ego networks
AllPoints <- NApoints  %>% map_df(~{
  
 points %>% 
    filter(name %in% names(ego(g2, nodes = .x)[[1]])) %>%
    summarise(Lon = mean(Lon, na.rm = T),
              Lat = mean(Lat, na.rm = T),
              count = nrow(.), name = .x)
  
})
```


##Check Geopoints

Some of the geopoints are not in the right location. Here I check the lat long distance with the distance provided by dataset

```{r}

Cabledist <- trans2 %>%
    mutate( Length = OHL.Length + Cable.Length ) %>%
    select(Bus.1, Bus.2, Length)

JieCoords <- calcgeodist(points, Cabledist)
JieCoords2 <- points %>%
    mutate(Lat = ifelse(name=="TILB40", Lat-10,Lat)) %>%
  calcgeodist(., Cabledist)

JonnoCoords <- points %>%
  filter(SubstationName!="Derby_South_132kV") %>% #The node is definately not Derby south
  mutate(Lat = ifelse(!is.na(Lat.2), Lat.2, Lat),
         Lon = ifelse(!is.na(Lon.2), Lon.2, Lon)) %>%
  calcgeodist(., Cabledist)


#calculate error

list(x= JieCoords, y = JieCoords2, z = JonnoCoords) %>%
  map_df(~{
    .x %>%
  filter(complete.cases(.)) %>%
with(., postResample(Length, geodist)) %>% 
      tibble(value = ., type = names(.))%>%
      spread(key = type, value = value)
  }) %>% mutate(type = c("JieCoords", "JieCoords2", "JonnoCoords"))


test <- unique(c(JonnoCoords$Bus.1, JonnoCoords$Bus.2)) %>% #substring(., 1,4) %>%
  map_df(~{
    
    JonnoCoords %>% mutate(temp = paste(.$Bus.1, .$Bus.2)) %>%
      #filter(Bus.1 == .x |Bus.2==.x) %>%
      filter(grepl(pattern = .x, x = temp )) %>%
      summarise(Error = sum(absdiff, na.rm = T),
                count = n()) %>%
      mutate(Bus = .x)
    
  })


ErrorWales <- test %>%
  filter(Bus %in% testRegion$name)

test2 <- test %>%
  mutate(Bus = substring(Bus, 1,4)) %>%
  group_by(Bus) %>%
  summarise_all(sum) %>%
  arrange(-Error)


```

##Minimise error

Some points are very hard to place having no clear location. This next section allows the points to be placed after searching across a grid to minimise the error with neighbouring vertices.

```{r}
target = "HUNE40"
JonnoCoords %>%
filter( grepl(target, Bus.1) |grepl(target, Bus.2))

testg <- make_ego_graph(g2, nodes = target)[[1]]

NodeNames <- vertex_attr(testg, "name")
Lat <-vertex_attr(testg, "Lat") %>% .[!is.na(.)]
Lon <- vertex_attr(testg, "Lon")  %>% .[!is.na(.)]

#mak a grid of coordinates based on the neighbouring positions
testCoords <- expand.grid(Lon = seq(min(Lon), max(Lon), length.out = 100),
               Lat = seq(min(Lat), max(Lat), length.out = 100))
point2 <- points %>%
  filter(name %in% NodeNames) 

#subset the trans2 data to make it faster to geolocate
trans3 <- trans2 %>%
filter( grepl(target, Bus.1) | grepl(target, Bus.2)) %>%
    mutate( Length = OHL.Length + Cable.Length ) %>%
    select(Bus.1, Bus.2, Length)


#find the error for each coordinate in the grid.
AllError <- 1:nrow(testCoords) %>%
  map_df(~{
    print(.x)
    Out <- point2 %>%
    mutate(Lon.2 = ifelse(name==target, testCoords$Lon[.x] , Lat.2),
           Lat.2 = ifelse(name==target, testCoords$Lat[.x] , Lat.2)) %>%
  mutate(Lat = ifelse(!is.na(Lat.2), Lat.2, Lat),
         Lon = ifelse(!is.na(Lon.2), Lon.2, Lon)) %>%
  calcgeodist(., trans3) %>%
  filter(complete.cases(.)) %>%
with(., postResample(Length, geodist)) %>% 
      tibble(value = ., type = names(.))%>%
      spread(key = type, value = value) %>%
  mutate(Lat = testCoords$Lat[.x],
         Lon = testCoords$Lon[.x] )
    
    return(Out)
    
  })

#plot the results
  AllError %>%
    ggplot(aes(x = Lon, y = Lat, fill = RMSE)) + geom_tile()
  
    AllError %>%
    ggplot(aes(x = Lon, y = Lat, fill = Rsquared)) + geom_tile()

      AllError %>%
    ggplot(aes(x = Lon, y = Lat, fill = MAE)) + geom_tile()
    
#A better way to do this would be to get the x and y error then sum across all connected node to get the total error components. then move the node that distance on x and y. This makes the force of all the connecting nodes 0 and is the minimum error point.
```


##Map Geo points to UK regions

```{r}
ShapeFolder <- "/home/jonno/Dropbox/SSE/Empty Homes/ShapeFiles/Local_Authority_Districts_December_2014_Ultra_Generalised_Clipped_Boundaries_in_Great_Britain"

UKLADS <- readOGR(file.path(ShapeFolder, "Local_Authority_Districts_December_2014_Ultra_Generalised_Clipped_Boundaries_in_Great_Britain.shp"))
  
g3 <- set.vertex.attribute(g2, "Lat", index = NApoints, value = AllPoints$Lat) %>%
  set.vertex.attribute(., "Lon",index = NApoints, value = AllPoints$Lon)

Positioning <- matrix(c(get.vertex.attribute(g3, "Lon"),
                        get.vertex.attribute(g3, "Lat")),
                      ncol = 2)
```


###GGplot map

```{r}

test <- Positioning %>% as_tibble()%>%
  rename(Latitude = V2,
         Longitude = V1)  %>%
  mutate(Node = get.vertex.attribute(g3, "name"),
         Degree = degree(g3),
         BalencedPower = get.vertex.attribute(g3, "BalencedPower"),
         NodeType = case_when(
           BalencedPower<0 ~"Demand",
           BalencedPower==0~"Transfer",
           TRUE ~"Generation"
         )) %>% GeoAndForceCoords(g3, .) 

#This suggests that end transfers occur near the center of the network
test %>%
  mutate(Voltage = factor(Voltage),
         PositionType = factor(PositionType),
         PositionType = fct_relevel(PositionType, "Geo Space", after = 0)) %>%
  ggplot(aes(y = Latitude, x = Longitude)) + 
  geom_line(aes( group = Link)) +
  facet_grid(~PositionType) +
  geom_point(data = . %>% filter(Degree ==1), aes(colour = NodeType)) +
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())


```


```{r}
GGmapData <- Positioning %>% as_tibble()%>%
  rename(Latitude = V1,
         Longitude = V2)  %>%
  mutate(Node = get.vertex.attribute(g3, "name")) %>%
  GeoAndForceCoords(g3,.)

#plot graph as ggplot
GGmapData %>%
  mutate(Voltage = factor(Voltage),
         PositionType = factor(PositionType),
         PositionType = fct_relevel(PositionType, "Geo Space", after = 0)) %>%
  ggplot(aes(x = Latitude, y = Longitude)) + 
  geom_line(aes(colour = Voltage, group = Link)) +
  facet_grid(~PositionType) +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
ggsave(file.path(FiguresFolder, "ggMapColouredEdges.pdf"))
  
```



```{r}

```


#Tweaking the package
The below code is used to tweak the R package, add to the documentation etc, etc

```{r}
library(devtools)
library(roxygen2)
setwd( "/home/jonno/PowerGridNetworking")
document()
setwd("/home/jonno")
install("PowerGridNetworking")
detach("package:PowergridNetworking", unload = TRUE)
library(PowerGridNetworking)

```


#Single attack exmaple

This chunk is just used so that I can have a test bed for function where I need to re-simulate an attack

```{r} 
#create graph
testg <- Proportional_Load(g, 1.5)

#get single deletion order
DeletionOrder <- DeleteOrders[1,-1] %>% t %>% .[,1]

 FixedNodes <- quo(FixedStrategyAttack(g, DeletionOrder))
    #suppres attack the grid messages
    AttackSeries <-AttackTheGrid(list(list(testg)),
                                                   FixedNodes,
                                                   referenceGrid = NULL,
                                                   MinMaxComp = 0,
                                                   TotalAttackRounds = 1000,
                                                   CascadeMode = TRUE)

  #try with much lower alpha
  AttackSeries <- read_rds(file.path("/media/jonno/Seagate Expansion Drive/ProportionalLoading/Saved_Sims/alpha_value_105", "Simulation_ID_1.rds"))

  test <- RoundTypeRemoved(AttackSeries)
  test1 <- test[[2]]

```

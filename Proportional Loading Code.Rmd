---
title: "Proportional Loading"
author: "Jonathan Bourne"
date: "14 February 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---





This script is for the PhD chapter/paper on proportional grid loading.

The goal of this paper is to compare real and proportional line limits and see what affect this has on cascading failures in the power-grid during attack.

Open data on powergrid modelling
https://www.sciencedirect.com/science/article/pii/S2352484716300877#f000005



LoadData2 says that all with voltage 0 are transformers. This implies they cannot be tripped and should have 1e5 as capacity

#Setup Block

```{r}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "zoo", "stringr","foreach", "doMC",  "xtable", "geomnet", "ggnetwork", "rlang", "animation", "ggridges", "poweRlaw", "Rtsne", "caret", "ranger", "xtable", "broom", "modelr", "yardstick")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)


sapply(packages, library, character.only = TRUE)


lapply(packages, library, character.only = TRUE)
library(PowerGridNetworking)

select <- dplyr::select

#Set up file system to read the correct folders this switches between aws and windows mode

basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
datafile <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ETYSAppendixB"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Proportional Line Limits" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
Functions <-"/home/jonno/Create_ETYS_network/Functions"
Tariff <- file.path(basewd,"Tariff and Transport")
PLwd <- "/media/jonno/Seagate Expansion Drive/ProportionalLoading"
Saved_Sims <- file.path(PLwd, "Saved_Sims")
Deletion_Order_Folder <- "/media/jonno/Seagate Expansion Drive/ProportionalLoading/DeletionOrder"
StratAttackWd <- "/media/jonno/Seagate Expansion Drive/ProportionalLoading/StratAttack"

source("/home/jonno/Create_ETYS_network/SubCode/LoadData2.R")


#FOr NetSci
#FiguresFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/NetSci2018 Poster/Figures"
```

#Create the Attack Orders
```{r}
#Set the path to a large enough storage
setwd(PLwd)

#Ensure there is powerflow
g <- PowerFlow(gbase, "FECK40")

AttackRounds <- 1000

#Create a reproducible attack order
seed<- 1589
filename <- "DeleteOrders100.rds"
if(file.exists(filename)){
  DeleteOrders <- readRDS(filename)
} else {
set.seed(seed)
DeleteOrders <- MultiAttackOrder(gbase, 100)  
saveRDS(DeleteOrders, filename)
}

```

#Set alpha colour gradient
```{r}
  AlphaGrad <-scale_colour_gradientn(colors = c("red",   "limegreen"),
                          breaks = c(1,2,7,20,50),
                          trans = "log",
                          values = scales::rescale((c(0, 6, 7, 20, 50))),
                          name = "Alpha value") 
```

#Comparison of line limit methods

This section compares artificial line limits created using a variety of metrics

```{r}

alpha_levels <- seq(1, 7, 0.05) #c(1, 1.05, 1.1, 1.2, 1.5, 2, 3, 5, 6,7)
#alpha_levels <- c(1, 1.05, 1.1, 1.2, 1.5, 2, 3, 5,6,7,8,9,10)

EdgeAttr <- get.edge.attribute(g) %>% names %>% 
  map(~{
    data_frame(temp = get.edge.attribute(g, name = .x)) %>%
      set_names(.x)
  }) %>% bind_cols() %>%
   filter(Link.Limit!=1e5, Voltage!=0
         )

PL_Limits <- alpha_levels %>% map(~{

  Proportional_Load(g, .x) %>% 
    get.edge.attribute(., "Link.Limit") %>%
    data_frame(temp = .) %>%
    set_names(paste0("alpha_value_", .x*100))
  
}
) %>% bind_cols() %>%
  filter(get.edge.attribute(g, "Voltage")!=0,
          get.edge.attribute(g, "Link.Limit")!= 1e5)
         
#The results

EdgeAttr2 <- PL_Limits

Limit_Method_RMSE <- EdgeAttr2 %>%
  map_df(~{
   c(postResample(.x, EdgeAttr$Link.Limit) , 
  mean(abs((EdgeAttr$Link.Limit - .x)/EdgeAttr$Link.Limit))) %>%
  matrix %>%
  t %>%
  data.frame() %>% set_names(names(postResample(EdgeAttr$Link.Limit, .x)), "MAPE" )
  
  }) %>%
  mutate(type = names(EdgeAttr2),
         method =  str_split(type, '_(?=[^_]+$)') %>% 
           transpose() %>% 
           .[[1]] %>% 
           unlist,
         Level = str_split(type, '_(?=[^_]+$)') %>% 
           transpose() %>% 
           .[[2]] %>% 
           unlist) %>%
  #This bit converts the Level to numeric. Useful when Only Alpha is being analysed
  mutate(Level = as.numeric(Level)/100)
 
Limit_Method_RMSE %>% 
ggplot(., aes(x = RMSE, y = MAPE, colour = Level)) + geom_point() +
  AlphaGrad +
  ggtitle("Error modelling line-limits using PL")
ggsave(file.path(FiguresFolder, "LimitMethodRMSE.pdf"))

Limit_Method_RMSE %>%
ggplot(., aes(x = RMSE, y = MAPE, colour = Level)) + geom_point() +
  AlphaGrad

Limit_Method_RMSE %>%
ggplot(., aes(x = MAPE, y = MAE, colour = Level)) + geom_point() +
  AlphaGrad

```

#Load level plot
```{r}

edges <- g %>% as_data_frame %>%
   mutate(alpha = Link.Limit/abs(PowerFlow),
          LoadLevel = 1/alpha,
          PercLL = percent_rank(LoadLevel),
          PercLinkLimit = percent_rank(Link.Limit),
          PercFlow = percent_rank(abs(PowerFlow)))
 
1/mean(edges$LoadLevel)
c(1.05, 1.1, 1.2, 1.5, 2, 3, 5, 6, 7, 10, 15, 20, 50)
LabelNames <- round(1/c(-.1, 0, .1,.2,.3,.4,.5,.6,.7,.8,.9,1), 2)
LabelNames[1:2] <- c("", ">10") 


ColourTypes <- data.frame(x=1:length(LabelNames[-c(1,2)]), y = LabelNames[-c(1,2)] %>% as.character %>% as.numeric())

TempPlot <- ColourTypes %>%
  ggplot(aes(x, y, colour = y)) +
  geom_point() +
  AlphaGrad

AccBuild <- ggplot_build(TempPlot)
AccBarCol <- c("blue", "blue",unique(AccBuild$data[[1]][[1]]))
names(AccBarCol) <-LabelNames %>%  as.factor %>% fct_relevel(., LabelNames) %>% levels
rm(TempPlot)

#Uses only Alpha which is much easier for people to understand
 edges %>%
   filter(is.finite(alpha), Link.Limit!= 100000) %>%
   ggplot(aes(x = LoadLevel)) + 
   geom_histogram(bins = 10, aes(y = (..count..)/sum(..count..)), fill = rev(AccBarCol[-c(1:2)]))+ #remove the fill to make it black again
  scale_y_continuous(labels = scales::percent, breaks = seq(0,.5, by= 0.05)) +
   labs(x = "Alpha level", y ="Percentage of total lines", title = "Distribution of line Alpha level across network\nusing real line limits under initial conditions")+
  annotate("text", x = .7, y = .2, label = "Mean Alpha = 5.4",  size=7) +
   scale_x_reverse(breaks = seq(1,-.1, by=-0.1), labels= rev(LabelNames))

 # edges %>%
 #   filter(is.finite(alpha), Link.Limit!= 100000) %>%
 #   ggplot(aes(x = LoadLevel)) + geom_histogram(bins = 10, aes(y = (..count..)/sum(..count..)))+ 
 #  scale_y_continuous(labels = scales::percent, breaks = seq(0,.5, by= 0.05)) +
 #  scale_x_continuous( breaks = seq(-1,5, by=0.1), labels = scales::percent)+ 
 #   labs(x = "Load Level", y ="Percentage of total lines", title = "Distribution of Load Level using real line limits under initial conditions") +
 #    annotate("text", x = .7, y = .2, label = "Mean Load Level = 19%",  size=7)
 ggsave(file.path(FiguresFolder,"LoadLevel.pdf"))

 edges %>%
   filter(is.finite(alpha), Link.Limit!= 100000) %>%
   ggplot(aes(x = LoadLevel, colour = as.factor(Voltage))) + geom_density()
 
 edges %>%
   filter(is.finite(alpha), Link.Limit!= 100000) %>%
   summarise(meanA = mean(alpha),
             medianA = median(alpha),
             meanLL = mean(LoadLevel),
             medianLL = median(LoadLevel))
 
 median(abs(edges$Link.Limit/edges$PowerFlow))
 mean(abs(edges$Link.Limit/edges$PowerFlow))
 
 edges %>%
   filter(Link.Limit != 1e5,
          Voltage !=0) %>%
   ggplot(aes(x = abs(PowerFlow), y = LoadLevel, colour = as.factor(Voltage))) +
   geom_point() +
   labs(x= "Absolute Power Flow MW", y="Load Level", title = "Relationship between power flow and Load Level", colour = "Voltage") 
  ggsave(file.path(FiguresFolder,"PowerFlowvsVoltage.pdf"))

 edges %>%
   filter(Link.Limit != 1e5,
          Voltage != 0) %>%
   ggplot(aes(x = PercFlow, y = PercLL, colour = as.factor(Voltage))) +
   geom_point()

```

#Generate Attack data

##Real line limits

```{r}

setwd(Saved_Sims)

folder <- "Real_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```


##Infinite limits

```{r}

setwd(Saved_Sims)

folder <- "Infinite_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = F)

```


##PL limits

This function saves networks.
Should the function should be changed so that it can handle edges as well as nodes.

```{r}

#The vector of alpha values to be tested
#alpha_vector <- c(1.05, 1.1, 1.2, 1.5, 2, 3, 5)
setwd(Saved_Sims)
alpha_vector <- c(35)

#Create the simulations for each of the alpha avalues using 100 simulations for each
alpha_vector %>% walk(~{
  gProp <- Proportional_Load(g, alpha = .x)
  
  folder <- paste0("alpha_value_",  .x*100)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
  SaveMultiAttacks(gProp, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)
  
}
  
)
  
```


##Modelled limits
```{r}

#Set seed and create model input variables
set.seed(1)
ModelInputVars <- g %>% as_data_frame %>%
  mutate(absPF = abs(PowerFlow),
         Voltage = as.factor(Voltage)) %>%
  select(Link.Limit, Voltage, absPF, Link)

#generate k=10 crossfold validated model
models <- ModelInputVars %>%
  filter(Link.Limit != 1e5) %>%
  crossv_kfold(k = 10) %>%
  mutate(model = map(train, ~ lm(Link.Limit ~ Voltage + absPF, data = .)))

#create predictions for each edge in the network
predictions <- models %>%
  unnest(map2(model, test, ~ augment(.x, newdata = .y)))

#Look at coefficiients
 models %>%
  unnest(map(model, ~ tidy(.x))) %>%
   select(.id, term, estimate) %>%
   spread(key = term, value = estimate)
 

 metrics(predictions ,Link.Limit, .fitted)

predictions %>%
  mutate(residual = (.fitted - Link.Limit)/Link.Limit) %>% #doesn't need to be relative. absolute gives half a random cloud
  select(Voltage, residual, absPF) %>%
  ggplot(aes(log10(absPF), residual)) +
  geom_point() +
  facet_wrap(~ Voltage)

#Create new edge limits using the predictions
NewEdges <- tibble(Link = get.edge.attribute(g, "Link") ) %>%
  left_join(., predictions) %>%
  mutate(.fitted = ifelse(is.na(.fitted), 1e5, .fitted))

LinModLims <- set_edge_attr(g, "Link.Limit", value = NewEdges$.fitted)

#Generate simulations
setwd(Saved_Sims)

folder <- "Linear_Model_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(LinModLims, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```



##Constant limits

takes the line with most power flow, adds x percent and uses that as the power limit for all line

```{r}
setwd(Saved_Sims)
#Needs to be redone as *1.05
folder <- "Constant_105"

LineLim<- max(get.edge.attribute(g, "PowerFlow"))*105

ConstantLims <- set.edge.attribute(g, "Link.Limit", value = LineLim)

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(ConstantLims, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```


##Constant voltage limits

```{r}
setwd(Saved_Sims)

folder <- "Constant_Volt_105"


Const_Volt <- EdgeAttr %>%
    group_by(Voltage) %>%
  mutate(constant = max(PowerFlow)*1.05) %>%
    ungroup %>%
  select(constant)

LineLim<- Const_Volt$constant

ConstantLims <- set.edge.attribute(g, "Link.Limit", value = LineLim)

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(ConstantLims, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```



##Extend the experiment
This is used to extend the original experiment from 150 node removals to complete collapse.
The whole experiment has been updated so this code chunk is no longer useful.
It is kept in for completness
```{r}
 
# setwd(PLwd)
# directories <- list.dirs()
# 
# directories[grepl("value_",directories)][-c(1,2,3,4,5,6)] %>% 
#   walk(~{
#     setwd(file.path(PLwd, .x))
#     print(.x)
#     ExtendMulltiAttack(list.files(), DeleteOrders)
#     gc()
#   }
# )


```


#Extracting stats

Extracting stats is slow this extracts the stats and saves them as a file.

```{r}

ExtractAttackStats(Saved_Sims, file.path(PLwd, "SummaryData"))

#Load the saved files
AttackRoundData <- list.files(path = file.path(PLwd,"SummaryData"), 
                              pattern = ".rds", 
                              full.names = TRUE) %>%
   map_df(~read_rds(.x))



```


#Construct attack summaries

Plots simple graphs from summary data

```{r}

SummariseMonteCarlo <- function(df){
 df %>% 
    mutate(PGfract = (max(PowerGen)- PowerGen)/max(PowerGen)) %>%
    group_by(NodesAttacked, alpha) %>%
    summarise(mean = mean(GCfract),
              sd = sd(GCfract),
              GC95 = quantile(GCfract, .95),
              GC05 = quantile(GCfract, .05),
              count = n(),
              mPGfract = mean(PGfract),
              sdPGfract = sd(PGfract),
              medPGfract = median(PGfract),
              PG95 = quantile(PGfract, .95),
              PG05 = quantile(PGfract, .05),
              PGmax = max(PGfract),
              PGmin = min(PGfract),
              mLoad = mean(GridLoading, na.rm = T),
              GL95 = quantile(GridLoading, .95, na.rm = T),
              GL05 = quantile(GridLoading, .05, na.rm = T)) %>%
    ungroup %>%
    group_by(alpha) %>%
     mutate(ID =n():1) %>%
    ungroup
  
}

SummaryofGC<- AttackRoundData %>%
  SummariseMonteCarlo %>%
  mutate(PercNum = NodesAttacked/958,
         alpha = sub("alpha_value_", "", alpha) %>% sub("_", " ", .))


PNodeDens <-  AttackRoundData %>%
  mutate(PercNum = round(NodesAttacked*100/958),
            LoadDrop = (first(GridLoading)-GridLoading)/first(GridLoading))


# test2 <- PNodeDens  %>%
#   select(GCfract, Blackout, alpha, PercNum) %>%
#   gather(., key="Type", value = "value",GCfract, Blackout) %>%
#   mutate(Type = ifelse(Type == "GCfract","Giant componant size reduction", "Blackout size"))
#   
# 
#  test2   %>%
#      filter(is.finite(value)) %>%
#   mutate(  PercAttacked= fct_rev(as_factor(paste0(PercNum, "%"))))  %>%
#   ggplot(aes(y = PercAttacked)) +
#   geom_density_ridges(aes(x = value, fill = alpha), alpha = 0.5)  + 
#   scale_x_continuous(labels=scales::percent)  +
#       facet_grid(~Type) +
#   labs(x = "Performance drop", y = "Percent of elements attacked",
#        title = "Change in the performance distribution as number of attacks increase") 


 NodeCollapse <- rbind(SummaryofGC %>%
  select(PercNum, mean, alpha, GC05, GC95, sd) %>% mutate(type = "Giant componant size reduction"),
SummaryofGC %>% 
  select(PercNum, mPGfract, alpha, PG05, PG95, sdPGfract) %>% mutate(type = "Blackout size") %>%
  rename(mean = mPGfract, GC05 = PG05, GC95 = PG95, sd = sdPGfract)
) %>% mutate(Target = "Node") %>%
   filter(alpha != "Constant 105", alpha != "Constant Volt_105" )

 NodeCollapse2<- NodeCollapse %>%
   filter(alpha != "Real Limits", alpha != "Linear Model_Limits") %>%
   mutate(alpha = ifelse(alpha == "Infinite Limits", "Inf", alpha),
          alpha = as.numeric(alpha)/100) %>%
   arrange(alpha)
 
AlphaCollapse <- NodeCollapse2 %>%
       filter(is.finite(sd))#need to remove infinte values 

RealCollapse <- NodeCollapse %>% 
               filter(alpha == "Real Limits",is.finite(sd))#need to remove infinte values 
   
ModelledCollapse <- NodeCollapse %>% 
               filter(alpha == "Linear Model_Limits",is.finite(sd))#need to remove infinte values 

NameOrder <- tibble(name = c("Real", "Modelled"), Colour = c("black", "blue")) %>% arrange(name)

AlphaCollapse %>% #need to remove infinte values 
  ggplot(aes(x = PercNum, y =  mean, group = alpha)) + 
  geom_line(aes(colour = as.numeric(alpha)), show.legend = TRUE) +  
  AlphaGrad +
  geom_line(data = RealCollapse, aes(fill = 'Real'), color = 'black') +
  geom_line(data = ModelledCollapse, aes(fill = 'Modelled'), color = 'blue') +
  scale_fill_manual("Line Limit", values=c(1, 1),
        guide=guide_legend(override.aes = list(colour=NameOrder$Colour))) +
  facet_grid(~type) +
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
  coord_cartesian(x = c(0,0.5)) +
  labs(title = "Change in Giant Componant and Blackout size as nodes are attacked" , 
       x = "Percent of elements attacked", 
       y = "Performance drop")
 
 ggsave(file.path(FiguresFolder,"GCandBlackoutChange.pdf"))


 AlphaCollapse %>% #need to remove infinte values 
  ggplot(aes(x = PercNum, y =  sd, group = alpha)) + 
  geom_line(aes(colour = as.numeric(alpha)), show.legend = TRUE) +  
  AlphaGrad +
  geom_line(data = RealCollapse, aes(fill = 'Real'), color = 'black') +
  geom_line(data = ModelledCollapse, aes(fill = 'Modelled'), color = 'blue') +
  scale_fill_manual("Line Limit", values=c(1, 1),
        guide=guide_legend(override.aes = list(colour=NameOrder$Colour))) +
  facet_grid(~type) +
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
  coord_cartesian(x = c(0,0.5))  +
  labs(title = "Size of 95-05 confidence interval as attack developes" , x = "Percent of elements attacked", y = "standard deviation")
 ggsave(file.path(FiguresFolder,"SDchange.pdf"))
 
```


#Deletion similarity

Get the round number that an edge was deleted.

```{r}

FolderVect <- list.files(path = Saved_Sims)
FileVect <- list.files(path = Deletion_Order_Folder) %>% gsub(".rds", "",.)
new.type <- FolderVect[!(FolderVect %in% FileVect)]

if(length(new.type)){
file.path(Saved_Sims, new.type) %>%
  walk( ~{
    print(.x)
    
  Removeddf <- list.files(path = .x, full.names = TRUE) %>% 
    map_df(~{
        file <- .x
        print(file)
        read_rds(file ) %>%
          RoundRemoved()  %>%
          mutate(Sim = gsub(".rds", "",file) %>% basename)
      }
    ) %>%
    group_by(Sim) %>%
    mutate(RoundRemoved = ifelse(is.na(RoundRemoved), max(RoundRemoved), RoundRemoved),
         alpha = basename(.x)) %>% 
    ungroup

  Removeddf %>%
        write_rds(x = ., paste0(file.path(Deletion_Order_Folder,basename(.x)), ".rds"))
  }
  )

} 
  
AllRemovedEdges <- list.files(Deletion_Order_Folder, full.names = TRUE) %>%
  map_df(~read_rds(.x))

```


#Correllation and TSNE prep

The TSNE shows that the real line limits are most similar to the constant line limits in terms of what failed

```{r}

TSNEdf <- AllRemovedEdges %>%
  spread(key = Edges, value = RoundRemoved, fill = 0)

key <- TSNEdf %>%
  select(Sim, alpha) %>%
  mutate(alpha2 = case_when(
  grepl("alpha", alpha) ~"Proportional",
  grepl("Constant_Volt", alpha) ~"Constant Volt",
  grepl("Constant", alpha) ~"Constant",
  grepl("Infinite", alpha) ~"Infinite",
  grepl("Linear_Model_Limits", alpha) ~"Linear Model Limits",
    TRUE ~ "Real Limits"
),
SimID = gsub("Simulation_ID_", "", Sim) %>% as.integer,
OriginalOrder = 1:nrow(.))


TSNEcormat <- TSNEdf %>%
  select(-Sim, -alpha) %>%
  as.matrix() %>% t %>% cor(method = "spearman")

dups <-duplicated(TSNEcormat) #no duplicates

key <- key#[!dups,] 
  
```

#TSNE
```{r}
set.seed(12358)
TsnecorOut1 <-TSNEcormat[!dups,] %>%  
  Rtsne(verbose = TRUE, eta = 1, max_iter = 5000, perplexity = 50, check_duplicates = FALSE) 

tsne_corplot <- data.frame(x1 = TsnecorOut1$Y[,1], 
                        y1 = TsnecorOut1$Y[,2]) %>%
  bind_cols(key) %>%
  mutate(alpha = sub("alpha_value_", "", alpha) %>% as.numeric()/100,
         alpha = ifelse(alpha2 == "Infinite", Inf, alpha))

tsne_corplot %>%
  filter(!grepl("Real", alpha), !grepl("Model", alpha)) %>%
    ggplot(aes(x=x1, y=y1)) + 
  geom_point(aes( color= alpha))+
   geom_point(data = filter(tsne_corplot, alpha2 == "Real Limits"), aes(fill = 'Real'), color = 'black') +
  geom_point(data =  filter(tsne_corplot, alpha2 == "Linear Model Limits"), aes(fill = 'Modelled'), color = 'blue') +
  scale_fill_manual("Line Limit", values=c(1, 1),
        guide=guide_legend(override.aes = list(colour=NameOrder$Colour))) +
AlphaGrad +
    ggtitle("TSNE plot of proportional loading and real line limits\n correlation similarity across all simulations")
ggsave(file.path(FiguresFolder, "TSNEcor.pdf"))


tsne_corplot %>%
    ggplot() + 
  geom_point(aes(x=x1, y=y1, color= alpha2))+ 
   #scale_colour_brewer(palette = "Set1")+
  ggtitle("TSNE plot of the Edge Round removal corellation\n between all Simulations by method")
ggsave(file.path(FiguresFolder, "TSNE_Method.pdf"))
```


#Boxplot of corellations

```{r}
AlphaOrder <- c("alpha value 1","alpha value 1.05","alpha value 1.1","alpha value 1.2","alpha value 1.5","alpha value 2" ,"alpha value 3","alpha value 5","alpha value 6","alpha value 7","alpha value 10","alpha value 15","alpha value 20","alpha value 50","Infinite Limits" ,"Linear Model Limits")

CleanNames <- function(df, TargetColumn, AlphaOrder){
temp <- df  %>%
  mutate_(temp1 = TargetColumn) %>%
 mutate(temp2 = temp1,
          temp2 = temp1 %>%
           str_replace_all(., "_", " ") %>%
           str_extract_all(., "([0-9])+")%>% as.numeric(.)/100,
temp3 = temp1 %>%
  str_replace_all(., "_", " ") %>%
  str_extract_all(., "([aA-zZ\\s])+", T) %>%
  paste0(., ifelse(is.na(temp2), "", temp2)),
        temp3 = temp3 %>% as.factor() %>%
  fct_relevel(., AlphaOrder)
) %>%
  select(temp3)
temp <-temp  %>%set_names(paste0(TargetColumn,"2")) 
 
temp <- bind_cols(df, temp)
return(temp)
}


NewOrder <- key %>%
  arrange(alpha, SimID) %>%
  mutate(NewOrder = 1:nrow(.))

RowIDS <- NewOrder %>%
  group_by(alpha) %>%
  summarise(Start = first(NewOrder),
            Last = last(NewOrder))

OrderedReal <- TSNEcormat[NewOrder$OriginalOrder, NewOrder$OriginalOrder]
OrderedReal <- OrderedReal[,NewOrder$alpha =="Real_Limits"]


AlphavsCor <- 1:nrow(RowIDS) %>% map_df(~{
  temp <- OrderedReal [RowIDS$Start[.x]:RowIDS$Last[.x],]
  data_frame(alpha = RowIDS$alpha[.x], cor = diag(temp))
}) %>%  filter(alpha != "Real_Limits") %>%
   filter(alpha != "Constant_105", alpha != "Constant_Volt_105" ) %>% ###This is added in to make only proportional!!!!
  CleanNames(., "alpha", AlphaOrder) %>%
  mutate( alpha = ifelse(alpha== "Infinite_Limits","Inf", alpha),
         alpha = gsub("alpha_value_", "", alpha),
         alpha = as.numeric(alpha)/100
)


TempPlot <-AlphavsCor %>%
    ggplot(aes(x= alpha2, y = cor, fill = alpha)) +
  geom_boxplot() +
  scale_fill_gradientn(colors = c("red",   "limegreen"),
                          breaks = c(1,2,7,20,50),
                          trans = "log",
                          values = scales::rescale((c(0, 6, 7, 20, 50))))

#Extract the colour codes from the ggplot object.
AccBuild <- ggplot_build(TempPlot)
AccBarCol <- c(unique(AccBuild$data[[1]][[1]]), "blue")
names(AccBarCol) <-AlphavsCor$alpha2 %>%  levels
rm(TempPlot)

AlphavsCor %>%
    ggplot(aes(x= alpha2, y = cor, fill = alpha2)) +
  geom_boxplot() +
    scale_fill_manual(values= AccBarCol) +
  scale_y_continuous( breaks = seq(0,1, by= 0.1)) +
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "alpha level", y ="Corellation with real line limits", title= "Edge removal rank corellation against real limits")

ggsave(file.path(FiguresFolder, "CorBoxPlot.pdf"))

AlphavsCor %>% 
  group_by(alpha) %>%
  summarise(mean= mean(cor),
            median = median(cor),
            sd = sd(cor))

AlphavsCor %>%
   filter(alpha %in% c("alpha_value_100" , "alpha_value_500","Infinite_Limits", "Linear_Model_Limits" )) %>% 
    ggplot(aes(x= as.factor(alpha), y = cor, fill = alpha)) +
  geom_boxplot() +
  scale_y_continuous( breaks = seq(0,1, by= 0.1)) +
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "alpha level", y ="Corellation with real line limits", title= "Edge removal rank corellation against real limits")

```


#Make random forest classifier

```{r}
setwd(PLwd)
trainset <- createDataPartition(key$alpha2, p = .75, list = FALSE)

ClassDict <- data_frame(alpha2 = unique(key$alpha2)) %>%
  mutate(ID = 1:nrow(.))

key <- key %>% left_join(., ClassDict, by = "alpha2")

datasetTrain <- bind_cols(select(key, ID), as_tibble(TSNEcormat)) %>% as.matrix()

rf_ranger_default <- ranger(data = datasetTrain[trainset,],
                              num.trees = 500,
                              mtry = 500,
                              dependent.variable.name = "ID", 
                              num.threads = 7, 
                              classification = TRUE)
  

Out<- predict(rf_ranger_default , data = datasetTrain[-trainset,], type = "response", predict.all = F)
confusionMatrix(Out$predictions, datasetTrain[-trainset,1])

#With correct class names
ConfMat <- confusionMatrix(ClassDict$alpha2[match(Out$predictions, ClassDict$ID)],
                ClassDict$alpha2[match(datasetTrain[-trainset,1], ClassDict$ID)]
                ) 

tibble(Estimate = ClassDict$alpha2[match(Out$predictions, ClassDict$ID)]%>% as.factor,
      Truth = ClassDict$alpha2[match(datasetTrain[-trainset,1], ClassDict$ID)] %>% as.factor
                ) %>%
conf_mat(truth = Truth, estimate = Estimate)

ConfMat$table %>%
  xtable(.,  caption = "Confusion matrix of random forest. Columns are truth, rows are estimate", label = "tab:ConfusionForest") %>%
  print(type = "latex", file = file.path(FiguresFolder, "ModelPerformance.txt"))

```


#Analysing damage done
This chunk produces Boxplots of the evaluation metrics for each simulation type.
It isn't hugley interesting so isn't included.

```{r}
#compares the damge of each line limit to the real damage using several metrics
DamageComparison <- function(df, Target = "Blackout"){
  
 df <- df %>% rename_(Target = Target)
  
  1:100 %>% map_df(~{

SimAttack <- df %>%
  filter(simulationID == .x) %>%
  select(Target, alpha, NodesAttacked) %>% 
  spread(key = alpha, value = Target) %>%
   select(-NodesAttacked) %>%
  filter(Real_Limits !=1)

SimAttack[is.na(SimAttack)] <- 1
  
  test2 <- SimAttack %>% map_df(~{
   c(postResample(.x, SimAttack$Real_Limits) , 
  mean(abs((SimAttack$Real_Limits - .x)/SimAttack$Real_Limits), na.rm = T)
  ) %>%
  matrix %>%
  t %>%
  data.frame() %>% 
      set_names(names(postResample(SimAttack$Real_Limits, .x)), "MAPE" )
}
) %>% mutate(type = names(SimAttack),
             SimulationID = .x)

}) %>% 
  rename(alpha  = type) %>%
  filter(alpha != "Real_Limits") %>%
    # mutate(alpha = ifelse(alpha== "Infinite_Limits","Inf", alpha),
    #      alpha = gsub("alpha_value_", "", alpha),
    #      alpha = as.numeric(alpha)/100) 
      CleanNames(., "alpha", AlphaOrder) 
}

#Sets up the plot for comparing different metrics, the metric of choice info is then added on

BasePlot <- function(df){

  df %>%
    ggplot(aes(x= alpha2, fill = alpha2)) +
    theme(legend.position = "none",  
        axis.text.x = element_text(angle = 45, hjust = 1))+
    scale_fill_manual(values= AccBarCol) + #requires the colours that have been previously calculated in the boxplot chunk
  scale_y_continuous( breaks = seq(0,1, by= 0.1))
  
  }

AccuracyAnalysis <- DamageComparison(AttackRoundData, "Blackout")

AccPlot <- AccuracyAnalysis  %>% BasePlot

 AccPlot + geom_boxplot(aes(y = RMSE)) +
  labs(x = "alpha", title = "RMSE against real line limits for all calculated alpha levels") 
ggsave(file.path(FiguresFolder, "RMSEChange.pdf"))


AccPlot + geom_boxplot(aes(y = Rsquared)) +
  labs(x = "alpha", title = "Rsquared against real line limits as alpha increases") 

AccPlot + geom_boxplot(aes(y = MAE)) +
  labs(x = "alpha", title = "MAE against real line limits as alpha increases") 

AccPlot + geom_boxplot(aes(y = log(MAPE))) +
  labs(x = "alpha", title = "MAPE against real line limits as alpha increases") 


#Analysis for giant component size

AccuracyAnalysisGC <- DamageComparison(AttackRoundData, "GCfract")


AccuracyAnalysisGC %>% BasePlot + geom_boxplot(aes(y = RMSE)) +
  labs(x = "alpha", title = "GCfract RMSE against real line limits as alpha increases") 
ggsave(file.path(FiguresFolder, "RMSEChangeGCfract.pdf"))


```

#Create model predicting line-limits.

```{r}

#Set seed and create model input variables
set.seed(1)
ModelInputVars <- g %>% as_data_frame %>%
  mutate(absPF = abs(PowerFlow),
         Voltage = as.factor(Voltage)) #%>%
  select(Link.Limit, Voltage, absPF, Link, Length)

#generate k=10 crossfold validated model
models <- ModelInputVars %>%
  filter(Link.Limit != 1e5) %>%
  crossv_kfold(k = 10) %>%
  mutate(model = map(train, ~ lm(Link.Limit~ Voltage +  Length, data = .)))

#create predictions for each edge in the network
predictions <- models %>%
  unnest(map2(model, test, ~ augment(.x, newdata = .y)))

#Model Performance
metrics(predictions ,Link.Limit, .fitted)


#Look at coefficiients
 models %>%
  unnest(map(model, ~ tidy(.x))) %>%
   select(.id, term, estimate) %>%
   spread(key = term, value = estimate)
 
predictions %>%
  mutate(residual = (.fitted - Link.Limit)/Link.Limit) %>% #doesn't need to be relative. absolute gives half a random cloud
  select(Voltage, residual, absPF) %>%
  ggplot(aes(log10(absPF), residual)) +
  geom_point() +
  facet_wrap(~ Voltage)


#there is some sort of log log relationship between Y and length
ModelInputVars %>%
ggplot(., aes(x=Length, y = Y, colour = Voltage)) +
  geom_point() + 
  scale_y_log10() + scale_x_log10() +
  labs(title = "Log 10 relatiobship between Line Length and Susceptance")

models <- ModelInputVars %>%
  mutate(logLength = log10(Length+1),
         logY = log10(Y)) %>%
  filter(Link.Limit != 1e5) %>%
  crossv_kfold(k = 10) %>%
  mutate(model = map(train, ~ lm(logY~ Voltage +  logLength, data = .)))

#create predictions for each edge in the network
Ypredictions <- models %>%
  unnest(map2(model, test, ~ augment(.x, newdata = .y)))

#Model Performance
Ypredictions %>%
  mutate(fitted2 = 10^.fitted) %>%
metrics(. ,logY, .fitted)

#The performance is much better than expected

```

#strategy difference


```{r}

ElecCen1<- ElectricalCentrality(g)

StratAttackVect <- c(as_data_frame(g, what = "vertices") %>% 
  as_tibble %>%
      mutate(metric = degree(g)) %>%
      arrange(desc(metric)) %>% .$name,

as_data_frame(g, what = "vertices") %>%
      mutate(metric = EntropicDegree(g, Scale = TRUE)) %>%
      arrange(desc(metric)) %>% .$name,

as_data_frame(g, what = "vertices") %>%
      mutate(metric = EntropicDegree(g, value = "PowerFlow", Scale = TRUE)) %>%
      arrange(desc(metric)) %>% .$name,


ElecCen1$NodeEC %>% arrange(-NodeEC) %>% .$Bus.Name,

 as_data_frame(g, what = "vertices") %>%
      mutate(metric = betweenness(g)) %>%
      arrange(desc(metric)) %>% .$name
) %>% matrix(., nrow = 5, byrow = T) %>%
  as_tibble %>%
  mutate(SimulationID = paste0("Simulation_ID_",1:5)) %>%
  select(SimulationID, everything()) %>%
  setNames(c("SimulationID", paste0("Target", 1:958)))


 
```


#Different strategies 1 load level
```{r}
#The vector of alpha values to be tested
alpha_vector <- c(1.05, 1.1,1.5, 2, 5,  10, 20, 50)

setwd(StratAttackWd)

#Create the simulations for each of the alpha avalues using 100 simulations for each
alpha_vector %>% walk(~{
  gProp <- Proportional_Load(g, alpha = .x)
  
  folder <- paste0("alpha_value_",  .x*100)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
  SaveMultiAttacks(gProp, StratAttackVect, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)
  
}
  
)

setwd(StratAttackWd)
folder <- "Real_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g,  test, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

setwd(StratAttackWd)
folder <- "Infinite_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, test, folder, TotalAttackRounds = AttackRounds, CascadeMode = F)

setwd(StratAttackWd)
folder <- "Linear_Model_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(LinModLims, test, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```



```{r}

RootFolder <- StratAttackWd

ExtractAttackStats(StratAttackWd, file.path(PLwd, "Attack_Strategy_SummaryData"))

AttackStratRoundData <- list.files(path = file.path(PLwd,"Attack_Strategy_SummaryData"), 
                              pattern = ".rds", 
                              full.names = TRUE) %>%
   map_df(~read_rds(.x)) %>%
  mutate(simulationID = case_when(
    simulationID == "1" ~"Degree" ,
    simulationID == "2" ~"EntDeg_LinkLimit",
    simulationID == "3" ~"EntDeg_PowerFlow",
    simulationID == "4" ~"Elec_Centrality",
    TRUE ~ "Centrality"
  ),
  alpha1 = alpha %>%
           str_replace_all(., "_", " ") %>%
           str_extract_all(., "([0-9])+")%>% as.numeric(.)/100,
alpha = alpha %>%
  str_replace_all(., "_", " ") %>%
  str_extract_all(., "([aA-zZ\\s])+", T) %>%
  paste0(., ifelse(is.na(alpha1), "", alpha1)),
  alpha = fct_relevel(alpha, "alpha value 5", after=2) %>%
  fct_relevel(., "alpha value 2", after=2) %>%
  fct_relevel(., "alpha value 1.5", after=2),
  PercNum = NodesAttacked/958) %>% 
  group_by(NodesAttacked, alpha) %>%
  mutate(rankblack = min_rank(-Blackout),
         rankGC = min_rank(GCfract)) %>%
  ungroup



AttackStratRoundData %>% #need to remove infinte values 
  ggplot(aes(x = PercNum, y =  GCfract, colour = simulationID)) + 
  geom_line() +  
  #geom_line(data = RealCollapse, aes(fill = 'Real'), color = 'black') +
  #geom_line(data = ModelledCollapse, aes(fill = 'Modelled'), color = 'blue') +
  scale_fill_manual("Line Limit", values=c(1, 1)) +
  facet_wrap(~alpha) +
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
  coord_cartesian(x = c(0,0.4)) +
  labs(title = "Change in Giant Componant and Blackout size as nodes are attacked" , 
       x = "Percent of elements attacked", 
       y = "Performance drop")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
   



AttackStratRoundData %>%
  filter(alpha == "Real Limits") %>%
  ggplot(aes(x = PercNum, y =  GCfract, colour = simulationID)) + 
  geom_line() +  
  scale_fill_manual("Line Limit", values=c(1, 1)) +
  #scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
  #coord_cartesian(x = c(0,0.5)) +
  labs(title = "Change in Giant Componant and Blackout size as nodes are attacked" , 
       x = "Percent of elements attacked", 
       y = "Performance drop")



test2 <-AttackStratRoundData %>%
  left_join(., 
            AttackStratRoundData %>%
  filter(alpha == "Real Limits") %>%
  select(NodesAttacked, simulationID, rankblack, rankGC), 
            by = c("NodesAttacked","simulationID")) %>% 
  ungroup %>%
         mutate(CorrectRank= rankblack.x==rankblack.y,
                rankdiff = rankblack.x-rankblack.y,
            r1 = as.factor(rankblack.x),
            r2= as.factor(rankblack.y)
    ) %>% ungroup

MapPairs <- expand.grid(unique(test2$simulationID),unique(test2$alpha) ) %>%
  as_tibble()

test3 <- map2_df(.x= MapPairs$Var1, .y=MapPairs$Var2, ~{
  test2   %>%
    filter(alpha ==.y) %>%
    group_by(alpha) %>%
    mutate(acc = accuracy(., estimate = r1, truth =  r2),
           AlphaRMSE = rmse(., estimate =rankblack.x, truth =  rankblack.y)) %>%
    filter(simulationID ==.x) %>%
    group_by(simulationID, alpha) %>%
    summarise(RMSE = rmse(., estimate =rankblack.x, truth =  rankblack.y),
              RSQ = rsq(., estimate =rankblack.x, truth =  rankblack.y),
              CorrectRank = sum(CorrectRank, na.rm = T),
              CorrectPerc = n(),
              AlphaAccuracy = first(acc),
              AlphaRMSE = first(AlphaRMSE),
              accuracy = accuracy(., estimate = r1, truth =  r2)
             )
          
  }) %>%
  filter(alpha!="Real Limits")
  

test2 %>%
  filter(alpha == "alpha value 5", simulationID=="Elec_Centrality") %>%
mutate(rankdiff = rankblack.x -rankblack.y) %>%
  ggplot(.,aes(x = NodesAttacked, y = rankdiff)) + geom_line() +
  labs(title= "Damage rank difference for Electrical centrality for alpha = 5\n rank difference of 0 means rank matches real results")


test3 %>%
  ggplot(., aes(x = simulationID, y = accuracy, fill = simulationID)) +
  geom_col() +
  facet_wrap(~alpha) +
  theme(axis.text.x = element_blank()) +
    labs(title= "The overall rank accuracy in terms of damage done\nby line limit setting and Attack strategy", 
       y = "Damage rank accuracy across entire simulation",
       x = "Attack Strategy"
      ) +
  guides(fill = guide_legend(title = "Attack Strategy"))

#boxplot
test2 %>%
  ggplot(., aes(x = alpha, y = rankdiff^2)) +
  geom_boxplot() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

AccBar<- test3 %>%
  group_by(alpha) %>%
  summarise(Accuracy = first(AlphaAccuracy)) %>% #AlphaAccuracy
  ggplot(aes(x= alpha, y = Accuracy, fill = alpha)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  labs(title= "The overall rank accuracy in terms of damage done by alpha level", 
       y = "Damage rank accuracy across entire simulation",
       x = "Line limit settings") 

AccBar


+
  scale_fill_manual(values = test$colour)

```


#Tweaking the package
The below code is used to tweak the R package, add to the documentation etc, etc

```{r}
library(devtools)
library(roxygen2)
setwd( "/home/jonno/PowerGridNetworking")
document()
setwd("/home/jonno")
install("PowerGridNetworking")
library(PowerGridNetworking)

```


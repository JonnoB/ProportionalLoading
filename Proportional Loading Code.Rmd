---
title: "Proportional Loading"
author: "Jonathan Bourne"
date: "14 February 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---



This script is for the PhD chapter/paper on proportional grid loading.

The goal of this paper is to compare real and proportional line limits and see what affect this has on cascading failures in the power-grid during attack.

Open data on powergrid modelling
https://www.sciencedirect.com/science/article/pii/S2352484716300877#f000005




#Setup Block

```{r}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "zoo", "stringr","foreach", "doMC",  "xtable", "geomnet", "ggnetwork", "rlang", "animation", "ggridges", "poweRlaw", "Rtsne", "caret", "ranger", "xtable")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)


sapply(packages, library, character.only = TRUE)


lapply(packages, library, character.only = TRUE)
library(PowerGridNetworking)

select <- dplyr::select

#Set up file system to read the correct folders this switches between aws and windows mode

basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
datafile <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ETYSAppendixB"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Proportional Line Limits" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
Functions <-"/home/jonno/Create_ETYS_network/Functions"
Tariff <- file.path(basewd,"Tariff and Transport")
PLwd <- "/media/jonno/Seagate Expansion Drive/ProportionalLoading"
Saved_Sims <- file.path(PLwd, "Saved_Sims")

source("/home/jonno/Create_ETYS_network/SubCode/LoadData2.R")


#FOr NetSci
#FiguresFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/NetSci2018 Poster/Figures"
```


#Create the Attack Orders
```{r}
#Set the path to a large enough storage
setwd(PLwd)

#Ensure there is powerflow
g <- PowerFlow(gbase, "FECK40")

AttackRounds <- 1000

#Create a reproducible attack order
seed<- 1589
filename <- "DeleteOrders100.rds"
if(file.exists(filename)){
  DeleteOrders <- readRDS(filename)
} else {
set.seed(seed)
DeleteOrders <- MultiAttackOrder(gbase, 100)  
saveRDS(DeleteOrders, filename)
}
```


#Comparison of line limit methods

This section compares artificial line limits created using a variety of metrics

```{r}

alpha_levels <- c(1.05, 1.1, 1.2, 1.5, 2, 3, 5)
#alpha_levels <- c(1, 1.05, 1.1, 1.2, 1.5, 2, 3, 5,6,7,8,9,10)

EdgeAttr <- get.edge.attribute(g) %>% names %>% 
  map(~{
    data_frame(temp = get.edge.attribute(g, name = .x)) %>%
      set_names(.x)
  }) %>% bind_cols() %>%
   filter(Link.Limit!=1e5, Voltage!=0
         )

PL_Limits <- alpha_levels %>% map(~{

  Proportional_Load(g, .x) %>% 
    get.edge.attribute(., "Link.Limit") %>%
    data_frame(temp = .) %>%
    set_names(paste0("alpha_value_", .x*100))
  
}
) %>% bind_cols() %>%
  filter(get.edge.attribute(g, "Voltage")!=0,
          get.edge.attribute(g, "Link.Limit")!= 1e5)
         

Constant_Limits <- alpha_levels %>% map(~{
EdgeAttr %>%
  mutate(constant = max(PowerFlow)*.x) %>%
  select(constant) %>%
  set_names(paste0("Constant_",.x*100))
}
) %>% bind_cols()

Constant_Volt_Limits <- alpha_levels %>% map(~{
EdgeAttr %>%
    group_by(Voltage) %>%
  mutate(constant = max(PowerFlow)*.x) %>%
    ungroup %>%
  select(constant) %>%
  set_names(paste0("Constant_Volt_",.x*100))
}
) %>% bind_cols()

# 
# ElectCentr <- ElectricalCentrality(g, Node_name = "name",
#                              Generation = "Generation",
#                              Demand = "Demand",
#                              Bus_order = "Bus.Order")
# 
# 
# ElectCentr2 <- ElectCentr %>%
#   rename(values = ElectricalCentrality)%>%
#   mutate(metric = "MyMetric",
#          Edgename = get.edge.attribute(g, "name"),
#          PowerFlow = get.edge.attribute(g, "PowerFlow"),
#          Link.Limit= get.edge.attribute(g, "Link.Limit"),
#          Voltage= get.edge.attribute(g, "Voltage"),
#          perc = values/max(values),
#          Scale_Fract = (values-min(values[values>0]))/(max(values)-min(values[values>0])),#minimum greater than 0
#          Scale_Fract = ifelse(Scale_Fract<0, 0, Scale_Fract))  %>% #prevents 0 from being negative
# #Alpha max 0.95 alpha min 0.05
# mutate(alpha_high = (20-1.05)*Scale_Fract + 1.05,
#        alpha_low = (20-1.05)*(1-Scale_Fract) + 1.05,
#        Edge_Centrality_high_95 = abs(PowerFlow*alpha_high),
#        Edge_Centrality_low_95 = abs(PowerFlow*alpha_low))  %>%
#    filter(Link.Limit!=1e5, Voltage!=0
#          )
# 
# 
# Edge_Centrality_high <- alpha_levels %>% map(~{
# ElectCentr2 %>%
#   mutate(constant = (20-.x)*Scale_Fract + .x) %>%
#     ungroup %>%
#   select(constant) %>%
#   set_names(paste0("Edge_Centrality_high_",.x*100))
# }
# ) %>% bind_cols()
# 
# Edge_Centrality_low <- alpha_levels %>% map(~{
# ElectCentr2 %>%
#   mutate(constant = (20-.x)*(1-Scale_Fract) + .x) %>%
#     ungroup %>%
#   select(constant) %>%
#   set_names(paste0("Edge_Centrality_low_",.x*100))
# }
# ) %>% bind_cols()

#The results

EdgeAttr2 <-  bind_cols(PL_Limits,Constant_Limits, Constant_Volt_Limits) 
%>%
  filter(Link.Limit!=1e5
         , Voltage!=0
         )

#EdgeAttr2 <-  bind_cols(PL_Limits,Constant_Limits, Constant_Volt_Limits, Edge_Centrality_high, Edge_Centrality_low)

Limit_Method_RMSE <- EdgeAttr2 %>%
  map_df(~{
   c(postResample(.x, EdgeAttr$Link.Limit) , 
  mean(abs((EdgeAttr$Link.Limit - .x)/EdgeAttr$Link.Limit))) %>%
  matrix %>%
  t %>%
  data.frame() %>% set_names(names(postResample(EdgeAttr$Link.Limit, .x)), "MAPE" )
  
  }) %>%
  mutate(type = names(EdgeAttr2),
         method =  str_split(type, '_(?=[^_]+$)') %>% 
           transpose() %>% 
           .[[1]] %>% 
           unlist,
         Level = str_split(type, '_(?=[^_]+$)') %>% 
           transpose() %>% 
           .[[2]] %>% 
           unlist)
 
Limit_Method_RMSE %>%
 #filter(grepl("Edge", type)) %>%
ggplot(., aes(x = log10(RMSE), y = (MAPE), colour = method)) + geom_point()
+
  coord_cartesian( y = c(0,20))
ggsave(file.path(FiguresFolder, "LimitMethodRMSE.pdf"))

Limit_Method_RMSE %>%
ggplot(., aes(x = RMSE, y = MAPE, colour = Level)) + geom_point() +
  coord_cartesian(x= c(0,5000), y = c(0,20))


Limit_Method_RMSE %>%
ggplot(., aes(x = MAPE, y = MAE, colour = method)) + geom_point()
+
  coord_cartesian(x = c(0,20), y = c(3000,8000))
```

#Load level plot
```{r}

edges <- g %>% as_data_frame %>%
   mutate(alpha = Link.Limit/abs(PowerFlow),
          LoadLevel = 1/alpha,
          PercLL = percent_rank(LoadLevel),
          PercLinkLimit = percent_rank(Link.Limit),
          PercFlow = percent_rank(abs(PowerFlow)))
%>%
  left_join(., ElectCentr, by = c("Link"="Edgename")) %>%
  mutate(PercECent = percent_rank(ElectricalCentrality))
 
edges %>%
   filter(is.finite(alpha), Link.Limit!= 100000) %>%
   ggplot(aes(x = LoadLevel)) + geom_histogram(bins = 10, aes(y = (..count..)/sum(..count..)))+ 
  scale_y_continuous(labels = scales::percent, breaks = seq(0,.5, by= 0.05)) +
  scale_x_continuous( breaks = seq(-1,5, by=0.1), labels = scales::percent)+ 
   labs(x = "Load Level", y ="Percentage of total lines", title = "Distribution of Load Level using real line limits under initial conditions") +
    annotate("text", x = .7, y = .2, label = "Mean Load Level = 19%",  size=7)
 ggsave(file.path(FiguresFolder,"LoadLevel.pdf"))

 
 edges %>%
   filter(is.finite(alpha), Link.Limit!= 100000) %>%
   ggplot(aes(x = LoadLevel, colour = as.factor(Voltage))) + geom_density()
 
 
 edges %>%
   filter(is.finite(alpha), Link.Limit!= 100000) %>%
   summarise(meanA = mean(alpha),
             medianA = median(alpha),
             meanLL = mean(LoadLevel),
             medianLL = median(LoadLevel))
 
 
 median(abs(edges$Link.Limit/edges$PowerFlow))
 mean(abs(edges$Link.Limit/edges$PowerFlow))
 
 edges %>%
   filter(Link.Limit != 1e5,
          Voltage !=0) %>%
   ggplot(aes(x = abs(PowerFlow), y = LoadLevel, colour = as.factor(Voltage))) +
   geom_point() +
   labs(x= "Absolute Power Flow MW", y="Load Level", title = "Relationship between power flow and Load Level")
 

 
 edges %>%
   filter(Link.Limit != 1e5,
          Voltage != 0) %>%
   ggplot(aes(x = PercFlow, y = PercLL, colour = as.factor(Voltage))) +
   geom_point()

```

#Generate Attack data

##Real line limits

```{r}
setwd(Saved_Sims)

folder <- "Real_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```


##Infinite limits

```{r}
setwd(Saved_Sims)

folder <- "Infinite_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = F)

```


##PL limits

This function saves networks.
Should the function should be changed so that it can handle edges as well as nodes.

```{r}

#The vector of alpha values to be tested
#alpha_vector <- c(1.05, 1.1, 1.2, 1.5, 2, 3, 5)
setwd(Saved_Sims)
alpha_vector <- c(50)

#Create the simulations for each of the alpha avalues using 100 simulations for each
alpha_vector %>% walk(~{
  gProp <- Proportional_Load(g, alpha = .x)
  
  folder <- paste0("alpha_value_",  .x*100)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
  SaveMultiAttacks(gProp, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)
  
}
  
)
  
```



```{r}
gProp <- Proportional_Load(g, alpha = 1)

 DeleteMe <- DeleteOrders %>%
    filter(SimulationID == "Simulation_ID_27") %>%
    select(-SimulationID) %>%
    t %>%
  as.vector

quo(expr = FixedStrategyAttack(g = g, DeletionOrder = DeleteMe))

test<- AttackTheGrid(list(gProp), , MinMaxComp = 0, TotalAttackRounds = 1000)

```




##Constant limits

takes the line with most power flow, adds x percent and uses that as the power limit for all line

```{r}
setwd(Saved_Sims)
#Needs to be redone as *1.05
folder <- "Constant_105"

LineLim<- max(get.edge.attribute(g, "PowerFlow"))*105

ConstantLims <- set.edge.attribute(g, "Link.Limit", value = LineLim)

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(ConstantLims, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```


##Constant voltage limits

```{r}
setwd(Saved_Sims)

folder <- "Constant_Volt_105"


Const_Volt <- EdgeAttr %>%
    group_by(Voltage) %>%
  mutate(constant = max(PowerFlow)*1.05) %>%
    ungroup %>%
  select(constant)

LineLim<- Const_Volt$constant

ConstantLims <- set.edge.attribute(g, "Link.Limit", value = LineLim)

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(ConstantLims, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```



##Extend the experiment
This is used to extend the original experiment from 150 node removals to complete collapse.
The whole experiment has been updated so this code chunk is no longer useful.
It is kept in for completness
```{r}
 
# setwd(PLwd)
# directories <- list.dirs()
# 
# directories[grepl("value_",directories)][-c(1,2,3,4,5,6)] %>% 
#   walk(~{
#     setwd(file.path(PLwd, .x))
#     print(.x)
#     ExtendMulltiAttack(list.files(), DeleteOrders)
#     gc()
#   }
# )


```


#Extracting stats

Extracting stats is slow this extracts the stats and saves them as a file.

```{r}

list.files(Saved_Sims , full.names = TRUE) %>% 
  walk(~{
    
    rootfolder <- .x
    targetfolder <- basename(.x)
    savename <-paste0(targetfolder, ".rds") %>% file.path(PLwd, "SummaryData",.)
    
    if(!file.exists(savename)){
      
      print(paste("Extracting summary data for", targetfolder))
      
      summarydata <-list.files(rootfolder) %>% 
          map_df(~{
            print(.x)
            read_rds(file.path(rootfolder, .x)) %>%
                   ExtractNetworkStats()%>%
                   mutate( simulationID = gsub("\\.rds", "", .x ) %>% gsub("Simulation_ID_", "", .) %>% as.integer)
            }
            ) %>%
          mutate(Cascade = TRUE, 
                 alpha = targetfolder)

      
      saveRDS(summarydata, savename)  
      
      print(paste("File", savename, "saved"))
      
    } else {print(paste("saved file for" , targetfolder, "exists"))}
  
    }
  )


#Load the saved files
AttackRoundData <- list.files(path = file.path(PLwd,"SummaryData"), 
                              pattern = ".rds", 
                              full.names = TRUE) %>%
   map_df(~read_rds(.x))



```


#Construct attack summaries

Plots simple graphs from summary data

```{r}
SummariseMonteCarlo <- function(df){
 df %>% 
    mutate(PGfract = (max(PowerGen)- PowerGen)/max(PowerGen)) %>%
    group_by(NodesAttacked, alpha) %>%
    summarise(mean = mean(GCfract),
              sd = sd(GCfract),
              GC95 = quantile(GCfract, .95),
              GC05 = quantile(GCfract, .05),
              count = n(),
              mPGfract = mean(PGfract),
              sdPGfract = sd(PGfract),
              medPGfract = median(PGfract),
              PG95 = quantile(PGfract, .95),
              PG05 = quantile(PGfract, .05),
              PGmax = max(PGfract),
              PGmin = min(PGfract),
              mLoad = mean(GridLoading, na.rm = T),
              GL95 = quantile(GridLoading, .95, na.rm = T),
              GL05 = quantile(GridLoading, .05, na.rm = T)) %>%
    ungroup %>%
    group_by(alpha) %>%
     mutate(ID =n():1) %>%
    ungroup
  
}


SummaryofGC<- AttackRoundData %>%
  SummariseMonteCarlo %>%
  mutate(PercNum = NodesAttacked/958,
         alpha = sub("alpha_value_", "", alpha) %>% sub("_", " ", .))


PNodeDens <-  AttackRoundData %>%
  mutate(PercNum = round(NodesAttacked*100/958),
            LoadDrop = (first(GridLoading)-GridLoading)/first(GridLoading))


test2 <- PNodeDens  %>%
  select(GCfract, Blackout, alpha, PercNum) %>%
  gather(., key="Type", value = "value",GCfract, Blackout) %>%
  mutate(Type = ifelse(Type == "GCfract","Giant componant size reduction", "Blackout size"))
  

 test2   %>%
     filter(is.finite(value)) %>%
  mutate(  PercAttacked= fct_rev(as_factor(paste0(PercNum, "%"))))  %>%
  ggplot(aes(y = PercAttacked)) +
  geom_density_ridges(aes(x = value, fill = alpha), alpha = 0.5)  + 
  scale_x_continuous(labels=scales::percent)  +
      facet_grid(~Type) +
  labs(x = "Performance drop", y = "Percent of elements attacked",
       title = "Change in the performance distribution as number of attacks increase") 


 NodeCollapse <- rbind(SummaryofGC %>%
  select(PercNum, mean, alpha, GC05, GC95, sd) %>% mutate(type = "Giant componant size reduction"),
SummaryofGC %>% 
  select(PercNum, mPGfract, alpha, PG05, PG95, sdPGfract) %>% mutate(type = "Blackout size") %>%
  rename(mean = mPGfract, GC05 = PG05, GC95 = PG95, sd = sdPGfract)
) %>% mutate(Target = "Node") %>%
   filter(alpha != "Constant 105", alpha != "Constant Volt_105" )

 
 NodeCollapse2<- NodeCollapse %>%
   filter(alpha != "Real Limits") %>%
   mutate(alpha = ifelse(alpha == "Infinite Limits", "Inf", alpha),
          alpha = as.numeric(alpha)/100) %>%
   arrange(alpha)
 
 NodeCollapse2 %>%
       filter(is.finite(sd)) %>% #need to remove infinte values 
    ggplot(aes(x= PercNum, y = mean, group = alpha)) +geom_line(aes(colour =alpha)) + 
   scale_colour_gradientn(colors = c("red",   "limegreen"),
                          #midpoint = log(median(NodeCollapse2$alpha)),
                          breaks = c(1,2,7,20,50),
                          trans = "log",
                          values = scales::rescale((c(0, 6, 7, 20, 50)))) +
   geom_line(data = NodeCollapse %>% 
               filter(alpha == "Real Limits",is.finite(sd)), 
             aes(x= (PercNum), y = mean),
             linetype = "dotdash") +
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
  coord_cartesian(x = c(0,0.5))+
  facet_grid(~type) +
  labs(title = "Change in Giant Componant and Blackout size as nodes are attacked" , x = "Percent of elements attacked", y = "Performance drop")
 
 ggsave(file.path(FiguresFolder,"GCandBlackoutChange.pdf"))


NodeCollapse %>% filter(alpha == "Real Limits",is.finite(sd))
 ggplot()+
 geom_line(data = NodeCollapse %>% filter(alpha == "Real Limits",is.finite(sd)), aes(x= (PercNum), y = mean))+
  facet_grid(~type)

 
#this shows the relationship between alpha values
test <-  NodeCollapse %>%
   mutate(rank = rank(PercNum)) %>%
   filter(type == "Blackout size", rank == 4949.5)
 
test %>%
  ggplot(aes(x= log(as.numeric(alpha)/100), y = (mean))) +
  geom_line()

NodeCollapse %>%
  ggplot(aes(x= PercNum, y = as.numeric(alpha), z = mean)) +  
  geom_tile(aes(fill = mean)) +
  stat_contour()


NodeCollapse2 %>%
    filter(is.finite(sd)) %>% #need to remove infinte values 
    ggplot(aes(x= PercNum, y =sd, group = alpha)) + geom_line(aes(colour =alpha)) + 
   scale_colour_gradientn(colors = c("red",   "limegreen"),
                          #midpoint = log(median(NodeCollapse2$alpha)),
                          breaks = c(1,2,7,20,50),
                          trans = "log",
                          values = scales::rescale((c(0, 6, 7, 20, 50)))) +
   geom_line(data = NodeCollapse %>% 
               filter(alpha == "Real Limits",is.finite(sd)), 
             aes(x= (PercNum), y = sd),
             linetype = "dotdash") +
   # geom_ribbon(aes(ymin=GC05, ymax=GC95, fill = alpha), alpha = 0.3) + 
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
       coord_cartesian(x = c(0,0.5))+
  facet_grid(~type) +
  labs(title = "Size of 95-05 confidence interval as attack developes" , x = "Percent of elements attacked", y = "standard deviation")
 ggsave(file.path(FiguresFolder,"SDchange.pdf"))
 
  NodeCollapse %>%
    mutate(alpha2 = ifelse(is.na(as.integer(alpha)), alpha, "PL")) %>%
       filter(is.finite(sd)) %>% #need to remove infinte values 
    filter(alpha2 != "PL") %>%
    ggplot(aes(x= PercNum, y = mean, colour = alpha2, group = alpha)) +geom_line() +
   # geom_ribbon(aes(ymin=GC05, ymax=GC95, fill = alpha), alpha = 0.3) + 
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
   coord_cartesian(x = c(0,0.5))+
  facet_grid(~type) +
  labs(title = "Change in Giant Componant and Blackout size as nodes are attacked" , x = "Percent of elements attacked", y = "Performance drop")

  
 test2 <- NodeCollapse %>%
    mutate(alpha2 = ifelse(is.na(as.integer(alpha)), alpha, "PL")) %>%
       filter(is.finite(sd)) %>% #need to remove infinte values 
    filter(alpha2 != "PL")
```


#Deletion similarity

Get the round number that an edge was deleted.

```{r}



setwd(PLwd)
if(!file.exists("AllRemovedEdges.rds")){
AllRemovedEdges <- list.files(path = Saved_Sims, full.names = TRUE) %>%
  map_df( ~{
    print(.x)
    setwd(.x)
    
    Removeddf <- list.files() %>% map_df(~{
 file <- .x
  print(file)
  read_rds(file ) %>%
  RoundRemoved()  %>%
    mutate(Sim = gsub(".rds", "",file))
  
  
  }
) %>%
  group_by(Sim) %>%
  mutate(RoundRemoved = ifelse(is.na(RoundRemoved), max(RoundRemoved), RoundRemoved),
         alpha = basename(.x)) %>% 
      ungroup
   
    setwd(PLwd)
    
    return(Removeddf)
  }
  )

saveRDS(AllRemovedEdges, "AllRemovedEdges.rds")
} else {
  AllRemovedEdges <- read_rds("AllRemovedEdges.rds")
}

```


#TSNE that thang

The TSNE shows that the real line limits are most similar to the constant line limits in terms of what failed

```{r}

TSNEdf <- AllRemovedEdges %>%
  spread(key = Edges, value = RoundRemoved, fill = 0)

key <- TSNEdf %>%
  select(Sim, alpha) %>%
  mutate(alpha2 = case_when(
  grepl("alpha", alpha) ~"Proportional",
  grepl("Constant_Volt", alpha) ~"Constant Volt",
  grepl("Constant", alpha) ~"Constant",
  grepl("Infinite", alpha) ~"Infinite",
    TRUE ~ "Real Limits"
),
SimID = gsub("Simulation_ID_", "", Sim) %>% as.integer,
OriginalOrder = 1:nrow(.))


TSNEmat <- TSNEdf %>%
  select(-Sim, -alpha) %>%
  as.matrix()

#This is irellevant as the the following section that performs a TSNE on the corellation is very clear and avoids confounding due to with high numbers
# 
# 
# TsneOut1 <-TSNEmat %>%  
#   Rtsne(verbose = TRUE, eta = 1, max_iter = 5000, perplexity = 50) 
# 
# TsneOut2 <-TSNEmat %>%  
#  Rtsne(verbose = TRUE, eta = 1, max_iter = 5000, perplexity = 200) #high seperation of alpha level
# 
# #Plot the TSNE graph
# tsne_plot <- data.frame(x1 = TsneOut1$Y[,1], 
#                         y1 = TsneOut1$Y[,2],
#                         x2 = TsneOut2$Y[,1], 
#                         y2 = TsneOut2$Y[,2]) %>%
#   bind_cols(key)
# 
# ggplot(tsne_plot) + geom_point(aes(x=x1, y=y1, color=alpha))+ 
#    theme(legend.position="none")
# 
# ggplot(tsne_plot) + geom_point(aes(x=x2, y=y2, color=alpha))+ 
#     scale_colour_brewer(palette = "Set1")
# 
# ggplot(tsne_plot) + geom_point(aes(x=x2, y=y2, color=alpha))+ scale_colour_brewer(palette = "Set1")
```

Corellation TSNSE
```{r}

TSNEcormat <- TSNEmat %>% t %>% cor(method = "spearman")

dups <-duplicated(TSNEcormat) 

key2 <- key#[!dups,] 
  

TsnecorOut1 <-TSNEcormat[!dups,] %>%  
  Rtsne(verbose = TRUE, eta = 1, max_iter = 5000, perplexity = 50, check_duplicates = FALSE) 

tsne_corplot <- data.frame(x1 = TsnecorOut1$Y[,1], 
                        y1 = TsnecorOut1$Y[,2]) %>%
  bind_cols(key2)

tsne_corplot %>%
  filter(!grepl("Constant", alpha)) %>%
    ggplot() + 
  geom_point(aes(x=x1, y=y1, color= alpha))+ 
     #theme(legend.position="none")+
   # scale_colour_brewer(palette = "Set1")+
  ggtitle("TSNE plot of proportional loading and real line limits\n correlation similarity across all simulations")
ggsave(file.path(FiguresFolder, "TSNEcor.pdf"))


tsne_corplot %>%
    ggplot() + 
  geom_point(aes(x=x1, y=y1, color= alpha2))+ 
   #scale_colour_brewer(palette = "Set1")+
  ggtitle("TSNE plot of the Edge Round removal corellation\n between all Simulations by method")
ggsave(file.path(FiguresFolder, "TSNE_Method.pdf"))



```

##Box plot of corellations

```{r}
test <- key2 %>%
  arrange(alpha, SimID) %>%
  mutate(NewOrder = 1:nrow(.))

RowIDS <- test %>%
  group_by(alpha) %>%
  summarise(Start = first(NewOrder),
            Last = last(NewOrder))

test2 <- TSNEcormat[test$OriginalOrder, test$OriginalOrder]
test2 <- test2[,test$alpha =="Real_Limits"]


test3 <- 1:nrow(RowIDS) %>% map_df(~{
  temp <- test2[RowIDS$Start[.x]:RowIDS$Last[.x],]
  data_frame(alpha = RowIDS$alpha[.x], cor = diag(temp))
})

test3 %>%
  filter(alpha != "Real_Limits") %>%
   filter(alpha != "Constant_105", alpha != "Constant_Volt_105" ) %>% ###This is added in to make only proportional!!!!
  mutate(alpha = ifelse(alpha== "Infinite_Limits","Inf", alpha),
         alpha = gsub("alpha_value_", "", alpha),
         alpha = as.numeric(alpha)/100) %>%
    ggplot(aes(x= as.factor(alpha), y = cor, fill = alpha)) +
  geom_boxplot() +
  scale_fill_gradientn(colors = c("red",   "limegreen"),
                          #midpoint = log(median(NodeCollapse2$alpha)),
                          breaks = c(1,2,7,20,50),
                          trans = "log",
                          values = scales::rescale((c(0, 6, 7, 20, 50))))+
  scale_y_continuous( breaks = seq(0,1, by= 0.1)) +
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "alpha level", y ="Corellation with real line limits", title= "Edge removal rank corellation against real limits")
ggsave(file.path(FiguresFolder, "CorBoxPlot.pdf"))

test3 %>% 
  group_by(alpha) %>%
  summarise(mean= mean(cor),
            median = median(cor),
            sd = sd(cor))

```


#Make random forest classifier

```{r}

trainset <- createDataPartition(key$alpha2, p = .75, list = FALSE)

ClassDict <- data_frame(alpha2 = unique(key$alpha2)) %>%
  mutate(ID = 1:nrow(.))

key2 <- key %>% left_join(., ClassDict, by = "alpha2")

datasetTrain <- bind_cols(select(key2, ID), as_tibble(TSNEcormat)) %>% as.matrix()

rf_ranger_default <- ranger(data = datasetTrain[trainset,],
                              num.trees = 500,
                              mtry = 500,
                              dependent.variable.name = "ID", 
                              num.threads = 7, 
                              classification = TRUE)
  

Out<- predict(rf_ranger_default , data = datasetTrain[-trainset,], type = "response", predict.all = F)
confusionMatrix(Out$predictions, datasetTrain[-trainset,1])

#With correct class names
ConfMat <- confusionMatrix(ClassDict$alpha2[match(Out$predictions, ClassDict$ID)],
                ClassDict$alpha2[match(datasetTrain[-trainset,1], ClassDict$ID)]
                ) 

ConfMat$table %>%
  xtable %>%
  print(type = "latex", file = file.path(FiguresFolder, "ModelPerformance.txt"))





```


#Analysing damage done
This chunk produces Boxplots of the evaluation metrics for each simulation type

```{r}


test <- 1:100 %>% map_df(~{

  #print(paste("Simulation ID", .x))
SimAttack <- AttackRoundData %>%
  filter(simulationID == .x) %>%
  select(Blackout, alpha, NodesAttacked) %>% 
  spread(key = alpha, value = Blackout) %>%
   select(-NodesAttacked) %>%
  filter(Real_Limits !=1)

SimAttack[is.na(SimAttack)] <- 1
  

  
  test2 <- SimAttack %>% map_df(~{
   c(postResample(.x, SimAttack$Real_Limits) , 
  mean(abs((SimAttack$Real_Limits - .x)/SimAttack$Real_Limits), na.rm = T)
  ) %>%
  matrix %>%
  t %>%
  data.frame() %>% 
      set_names(names(postResample(SimAttack$Real_Limits, .x)), "MAPE" )
}
) %>% mutate(type = names(SimAttack),
             SimulationID = .x)

}) 


test %>% 
  rename(alpha  = type) %>%
  filter(alpha != "Real_Limits", alpha !="Constant_105", alpha !="Constant_Volt_105") %>%
    mutate(alpha = ifelse(alpha== "Infinite_Limits","Inf", alpha),
         alpha = gsub("alpha_value_", "", alpha),
         alpha = as.numeric(alpha)/100) %>%
  ggplot(aes(x= as.factor(alpha), y = RMSE, fill = alpha)) + geom_boxplot()+
  theme(legend.position = "none",  
        axis.text.x = element_text(angle = 45, hjust = 1)) +
   scale_fill_gradientn(colors = c("red",   "limegreen"),
                          #midpoint = log(median(NodeCollapse2$alpha)),
                          breaks = c(1,2,7,20,50),
                          trans = "log",
                          values = scales::rescale((c(0, 6, 7, 20, 50))))+
  scale_y_continuous( breaks = seq(0,1, by= 0.1)) +
  ggtitle("RMSE against real line limits as alpha increases")
ggsave(file.path(FiguresFolder, "RMSEChange.pdf"))

test %>%
  filter(type != "Real_Limits") %>%
  ggplot(aes(x= type, y = Rsquared, fill = type)) + geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

test %>%
  filter(type != "Real_Limits") %>%
  ggplot(aes(x= type, y = MAE, fill = type)) + geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

test %>%
  filter(type != "Real_Limits") %>%
  ggplot(aes(x= type, y = MAPE, fill = type)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_log10()

```


#Predict Line limits
```{r}

breaks = seq(0,1,0.1)

#edges 1 is made in the load level chunk
edges2 <- edges %>%
     filter(Link.Limit != 1e5,
          Voltage != 0,
          PowerFlow!=0) %>%
  mutate(absPF = abs(PowerFlow),
         Voltage = as.factor(Voltage),
         LLbin = cut(LoadLevel, breaks, labels = breaks[1:10]+0.05),
         LLbin2 = LLbin %>% as.character %>% as.numeric)

edges2 %>%
 group_by(Voltage, LLbin) %>%
  summarise(counts = n()) %>%
  mutate(counts = counts/sum(counts)) %>%
ggplot(., aes(x = Voltage, y = LLbin)) +
    geom_tile(aes(fill = counts)) 



trainset <- createDataPartition(as.factor(edges2$Voltage), p = .75, list = FALSE)[,1] #trainset as vector
trainset2 <- createDataPartition(edges2$LLbin, p = .75, list = FALSE)[,1] #trainset as vector


Mod1 <- lm(LLbin2 ~Voltage  + (absPF), data = edges2[trainset,])
summary(Mod1)
Preds <- predict(Mod1, edges2[-trainset,])

postResample(Preds, edges2$LLbin2[-trainset])

Predsdf <- data_frame(Preds, Obs = edges2$LLbin2[-trainset],
                      PowerFlow = edges2$PowerFlow[-trainset]) %>%
  mutate(error = Obs-Preds,
         abserror = abs(error),
         Voltage = edges2$Voltage[-trainset],
         PercError = error/Obs,
         absPercError = abserror/Obs,
         direction = PowerFlow>1)

Predsdf %>%
ggplot(aes(x= Obs, y=(PercError), colour = Voltage)) +geom_point()


Predsdf %>%
ggplot(aes(x= log10(abserror), y=PercError, colour = Voltage)) +geom_point()
+
  coord_cartesian(y=c(1,-2))

median(Predsdf$absPercError)
mean(Predsdf$absPercError)

cor(abs(edges2$PowerFlow), edges2$Link.Limit)

Mod2 <- svm(LLbin ~Voltage  + log10(absPF)+ Y, data = edges2[trainset,], kernel = "radial", gamma = 1, degree = 3)
summary(Mod2)
Preds2 <- predict(Mod2, edges2[-trainset,])

confusionMatrix(Preds2, edges2$LLbin[-trainset])

postResample(Preds2 %>% as.character %>% as.numeric, edges2$LLbin2[-trainset])

postResample(Preds2, edges2$Link.Limit[-trainset])


Predsdf2 <- data_frame(Preds = Preds2 %>% as.character %>% as.numeric, Obs = edges2$LLbin2[-trainset],
                      PowerFlow = edges2$PowerFlow[-trainset]) %>%
  mutate(error = Obs-Preds,
         abserror = abs(error),
         Voltage = edges2$Voltage[-trainset],
         PercError = error/Obs,
         absPercError = abserror/Obs,
         direction = PowerFlow>1)

Predsdf2 %>%
ggplot(aes(x= abserror, y=PercError, colour = Voltage)) +geom_point()
+
  coord_cartesian(y=c(1,-2))


#seperate voltages

Mod3 <- svm(Voltage ~LoadLevel  + log10(absPF), data = edges2[trainset,], kernel = "radial", gamma = 1, degree = 3)
summary(Mod3)
Preds3 <- predict(Mod3, edges2[-trainset,])

confusionMatrix(Preds3, edges2$Voltage[-trainset])

#Random forest about 90% accruacy
Mod4 <- ranger(Voltage~., select(edges2[trainset,], LoadLevel, absPF, Voltage))

summary(Mod4)
Preds4 <- predict(Mod4, edges2[-trainset,])

confusionMatrix(Preds4$predictions, edges2$Voltage[-trainset])

```


#model PL result

Input alpha level and number of edges attacked and return the amount of damage done.
This effectively maps the 3-d surface of the attack.

```{r}

test <-  NodeCollapse %>%
   mutate(alpha2 = ifelse(is.na(as.integer(alpha)), alpha, "PL")) %>%
   filter(is.finite(sd), alpha2 == "PL") %>% 
    mutate(alpha = as.numeric(alpha),
           logmean = log(mean),
           logalpha = log(alpha)) %>%
  filter(mean != 0)

set.seed(1235)
trainset2 <- createDataPartition(test$mean, p = .75, list = FALSE)[,1] #trainset as vector

#doesn't work only works on two dimensional data
fit <- nls(y ~ SSlogis(x, Asym, xmid, scal), data = data.frame( x= test$alpha, y1 = test$PercNum, y2 = test$mean) %>% filter(y !=0))

#Mod1 <- lm(mean ~ alpha + PercNum + alpha*PercNum + alpha^2+ PercNum^2, data = test[trainset2,])
Mod1 <- lm(mean ~ logalpha + PercNum + logalpha*PercNum, data = test[trainset2,])
summary(Mod1)
Preds <- predict(Mod1, test[-trainset2,])

postResample(Preds, test$mean[-trainset2])

Predsdf2 <- data_frame(Preds = Preds %>% as.character %>% as.numeric, Obs = test$mean[-trainset2], PercNum = test$PercNum[-trainset2]) %>%
  mutate(error = Obs-Preds,
         abserror = abs(error),
         PercError = error/Obs,
         absPercError = abserror/Obs,
         alpha = test$alpha[-trainset2])
Predsdf2 %>%
ggplot(aes(x= abserror, y=log10(absPercError), colour = as.factor(alpha))) +geom_point()

Predsdf2 %>%
ggplot(aes(x= alpha, y=PercNum, colour = (error)^2)) +geom_point()

Predsdf2 %>%
ggplot(aes(x= as.factor(alpha), y=log10(absPercError), fill = as.factor(alpha))) +geom_boxplot()

wireframe(mean ~logalpha*PercNum, data = test,
          drape = T,
          colorkey = T
          )


Mod2 <- lm(logalpha ~ mean + PercNum + mean*PercNum, data = test[trainset2,])
summary(Mod2)
Preds2 <- predict(Mod2, test[-trainset2,])
postResample(Preds2, test$logalpha[-trainset2])

 
 NodeCollapse2 %>%
       filter(is.finite(sd)) %>% #need to remove infinte values 
    ggplot(aes(x= PercNum, y = log(alpha), colour = mean)) +geom_point()

 
 

 
NodeCollapse3 <- NodeCollapse2 %>%
   filter(is.finite(mean), is.finite(alpha), mean != 0,
          !duplicated(paste(PercNum, alpha, sep="-"))) 

 g<- expand.grid(PercNum =unique(NodeCollapse3$PercNum), alpha = seq(1,50,0.1))%>%
   as_tibble %>%
   mutate(alpha2 = alpha^2)
 
 MaxLim <- NodeCollapse3 %>%
   group_by(alpha) %>%
   summarise(PercNum = max(PercNum)) %>%
   ungroup %>%
   mutate(alpha2 = alpha^2)

 ModLim <- lm(PercNum~ (alpha) + (alpha2), data = MaxLim)
 summary(ModLim)
 

 
 MaxLim2 <- data_frame(alpha = seq(1,50,0.05)) %>%
   mutate(alpha2= alpha^2)
 
MaxLim2<- MaxLim2%>% mutate(PercNum = predict(ModLim, MaxLim2))
 
ggplot(MaxLim, aes(x = alpha, y = PercNum)) +geom_point() +
   geom_line(data = data.frame(PercNum2 = predict(ModLim, MaxLim2), alpha2 = MaxLim2$alpha),
             aes(y = PercNum2, x = alpha2))
 
ggplot(MaxLim, aes(x = (alpha), y = PercNum)) +geom_point() 
 
ktest <- kriging(x = NodeCollapse3$PercNum, y = NodeCollapse3$alpha, response = NodeCollapse3$mean, lags = 3, model = "gaussian")
 

ktest2 <- NodeCollapse2 %>% select(mean, PercNum, alpha) %>%
  mutate(dups1 = paste(PercNum, alpha, sep="-"),
         dups2 = duplicated(dups1)) %>%
   filter(is.finite(mean), is.finite(alpha), mean != 0, 
          duplicated(dups))  

ktest2 %>%
  filter(dups == "0.00104384133611691-1")


spatdf <- NodeCollapse3 %>%
  rename(x = PercNum, y = alpha)

coordinates(spatdf) <- ~x+y
Var <- variogram(mean~x+y, spatdf)
plot(Var)
m <- fit.variogram(Var, vgm("Gau"))


plot(Var,m)

k <- gstat(formula=mean~1, locations=spatdf, model=m)

g2<- g %>%
  rename(x = PercNum, y = alpha)
coordinates(g2) <- ~x+y

kp <- predict(k, g2)

setwd(PLwd)
saveRDS(kp, "Kreiged.rds")

test <- as_tibble(kp)

test %>%
  ggplot(aes(x,y, colour = var1.pred)) +geom_point()

```



#Tweaking the package
The below code is used to tweak the R package, add to the documentation etc, etc

```{r}
library(devtools)
library(roxygen2)
setwd( "/home/jonno/PowerGridNetworking")
document()
setwd("/home/jonno")
install("PowerGridNetworking")
library(PowerGridNetworking)

```




---
title: "Proportional Loading"
author: "Jonathan Bourne"
date: "14 February 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

This script is for the PhD chapter/paper on proportional grid loading.

The goal of this paper is to compare real and proportional line limits and see what affect this has on cascading failures in the power-grid during attack.

#Setup Block


```{r}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "zoo", "stringr","foreach", "doMC",  "xtable", "geomnet", "ggnetwork", "rlang", "animation", "ggridges", "poweRlaw", "Rtsne", "caret", "ranger")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)


lapply(packages, library, character.only = TRUE)
library(PowerGridNetworking)

select <- dplyr::select

#Set up file system to read the correct folders this switches between aws and windows mode

basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
datafile <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ETYSAppendixB"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Proportional Line Limits" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
Functions <-"/home/jonno/Create_ETYS_network/Functions"
Tariff <- file.path(basewd,"Tariff and Transport")
PLwd <- "/media/jonno/Seagate Expansion Drive/ProportionalLoading"

source("/home/jonno/Create_ETYS_network/SubCode/LoadData2.R")

```

#Create the Attack Orders
```{r}
#Set the path to a large enough storage
setwd(PLwd)

#Ensure there is powerflow
g <- PowerFlow(gbase, "FECK40")

AttackRounds <- 1000

#Create a reproducible attack order
seed<- 1589
filename <- "DeleteOrders100.rds"
if(file.exists(filename)){
  DeleteOrders <- readRDS(filename)
} else {
set.seed(seed)
DeleteOrders <- MultiAttackOrder(gbase, 100)  
saveRDS(DeleteOrders, filename)
}
```


#Perform Random attack on real line limits

```{r}
folder <- "Real_Limits"

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)

```


#Generate PL networks

This function saves networks.
Should the function should be changed so that it can handle edges as well as nodes.

```{r}

#The vector of alpha values to be tested
#alpha_vector <- c(1.05, 1.1, 1.2, 1.5, 2, 3, 5)
alpha_vector <- c( 5)

#Create the simulations for each of the alpha avalues using 100 simulations for each
alpha_vector %>% walk(~{
  gProp <- Proportional_Load(g, alpha = .x)
  
  folder <- paste0("alpha_value_",  .x*100)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
  SaveMultiAttacks(gProp, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T)
  
}
  
)
  
```

##Extend the experiment
This is used to extend the original experiment from 150 node removals to complete collapse
```{r}
 
# setwd(PLwd)
# directories <- list.dirs()
# 
# directories[grepl("value_",directories)][-c(1,2,3,4,5,6)] %>% 
#   walk(~{
#     setwd(file.path(PLwd, .x))
#     print(.x)
#     ExtendMulltiAttack(list.files(), DeleteOrders)
#     gc()
#   }
# )


```



#Extracting stats

Extracting stats is slow this extracts the stats and saves them as a file.

```{r}

Sim_summary <- list.files(PLwd, patter = "(alpha)|(Real)") %>% 
  file.path(PLwd,.) %>% map_df(~{
    
    rootfolder <- .x
    targetfolder <- basename(.x)
    
    if(!file.exists(paste0(targetfolder, ".rds"))){
      
      print(paste("Extracting summary data for", targetfolder))
      
      summarydata <-list.files( rootfolder) %>% 
          map_df(~read_rds(file.path(rootfolder, .x)) %>%
                   ExtractNetworkStats()) %>%
          mutate(Cascade = TRUE, 
                 alpha = targetfolder,
                 simulationID = .x)
      savename <-paste0(targetfolder, ".rds")
      
      saveRDS(summarydata, file.path("SummaryData",savename))  
      
      print(paste("File", savename, "saved"))
      
    } else {print(paste("saved file for" , targetfolder, "exists"))}
  
    }
  )

#temp fix needs to be done properly
setwd(file.path(PLwd,"SummaryData"))
AttackRoundData <- list.files(pattern = ".rds") %>%
  map_df(~read_rds(.x))
setwd(PLwd)


```


#Construct attack summaries

Plots simple graphs from summary data

```{r}
SummariseMonteCarlo <- function(df){
 df %>% 
    mutate(PGfract = (max(PowerGen)- PowerGen)/max(PowerGen)) %>%
    group_by(NodesAttacked, alpha) %>%
    summarise(mean = mean(GCfract),
              sd = sd(GCfract),
              GC95 = quantile(GCfract, .95),
              GC05 = quantile(GCfract, .05),
              count = n(),
              mPGfract = mean(PGfract),
              sdPGfract = sd(PGfract),
              medPGfract = median(PGfract),
              PG95 = quantile(PGfract, .95),
              PG05 = quantile(PGfract, .05),
              PGmax = max(PGfract),
              PGmin = min(PGfract),
              mLoad = mean(GridLoading, na.rm = T),
              GL95 = quantile(GridLoading, .95, na.rm = T),
              GL05 = quantile(GridLoading, .05, na.rm = T)) %>%
    ungroup %>%
    group_by(alpha) %>%
     mutate(ID =n():1) %>%
    ungroup
  
}


SummaryofGC<- AttackRoundData %>%
  SummariseMonteCarlo %>%
  mutate(PercNum = NodesAttacked/958,
         alpha = sub("alpha_value_", "", alpha) %>% sub("_", " ", .))

PNodeDens <-  AttackRoundData %>%
  mutate(PercNum = round(NodesAttacked*100/958),
            LoadDrop = (first(GridLoading)-GridLoading)/first(GridLoading))


SummaryofGC %>%
    ggplot(aes(x= PercNum, y = mean, colour = alpha)) +geom_line() +
    geom_ribbon(aes(ymin=GL05, ymax=GL95, fill = Cascade), alpha = 0.3)


test2 <- PNodeDens  %>%
  select(GCfract, Blackout, alpha, PercNum) %>%
  gather(., key="Type", value = "value",GCfract, Blackout) %>%
  mutate(Type = ifelse(Type == "GCfract","Giant componant size reduction", "Blackout size"))
  

 test2   %>%
  mutate(  PercAttacked= fct_rev(as_factor(paste0(PercNum, "%"))))  %>%
  ggplot(aes(y = PercAttacked)) +
  geom_density_ridges(aes(x = value, fill = alpha), alpha = 0.5)  + 
  scale_x_continuous(labels=scales::percent)  +
      facet_grid(~Type) +
  labs(x = "Performance drop", y = "Percent of elements attacked",
       title = "Change in the performance distribution as number of attacks increase") 


 NodeCollapse <- rbind(SummaryofGC %>%
  select(PercNum, mean, alpha, GC05, GC95, sd) %>% mutate(type = "Giant componant size reduction"),
SummaryofGC %>% 
  select(PercNum, mPGfract, alpha, PG05, PG95, sdPGfract) %>% mutate(type = "Blackout size") %>%
  rename(mean = mPGfract, GC05 = PG05, GC95 = PG95, sd = sdPGfract)
) %>% mutate(Target = "Node")

 
 NodeCollapse %>%
       filter(is.finite(sd)) %>% #need to remove infinte values 
    ggplot(aes(x= PercNum, y = mean, colour = alpha)) +geom_line() +
   # geom_ribbon(aes(ymin=GC05, ymax=GC95, fill = alpha), alpha = 0.3) + 
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
   coord_cartesian(x = c(0,0.5))+
  facet_grid(~type) +
  labs(title = "Change in Giant Componant and Blackout size as nodes are attacked" , x = "Percent of elements attacked", y = "Performance drop")
 
 ggsave(file.path(FiguresFolder,"GCandBlackoutChange.pdf"))
  
  NodeCollapse %>%
    filter(is.finite(sd)) %>% #need to remove infinte values 
    ggplot(aes(x= PercNum, y =sd, colour = alpha)) +geom_line() +
   # geom_ribbon(aes(ymin=GC05, ymax=GC95, fill = alpha), alpha = 0.3) + 
  scale_x_continuous(labels=scales::percent) + 
  scale_y_continuous(labels=scales::percent) +
       coord_cartesian(x = c(0,0.5))+
  facet_grid(~type) +
  labs(title = "Size of 95-05 confidence interval as attack developes" , x = "Percent of elements attacked", y = "standard deviation")
 ggsave(file.path(FiguresFolder,"SDchange.pdf"))
 
```


#Deletion similarity

Get the round number that an edge was deleted.


```{r}

setwd(PLwd)
if(!file.exists("AllRemovedEdges.rds")){
AllRemovedEdges <- list.dirs(path = ".", full.names = TRUE, recursive = TRUE)[-1] %>%
  map_df( ~{
    print(.x)
    setwd(.x)
    
    Removeddf <- list.files() %>% map_df(~{
 file <- .x
  print(file)
  read_rds(file ) %>%
  RoundRemoved()  %>%
    mutate(Sim = gsub(".rds", "",file))
  
  
  }
) %>%
  group_by(Sim) %>%
  mutate(RoundRemoved = ifelse(is.na(RoundRemoved), max(RoundRemoved), RoundRemoved),
         alpha = basename(.x)) %>% 
      ungroup
   
    setwd(PLwd)
    
    return(Removeddf)
  }
  )

save_rds(AllRemovedEdges, "AllRemovedEdges.rds")
} else {
  AllRemovedEdges <- read_rds("AllRemovedEdges.rds")
}

```

TSNE that thang
```{r}

TSNEdf <- AllRemovedEdges %>%
  spread(key = Edges, value = RoundRemoved, fill = 0)

key <- TSNEdf %>%
  select(Sim, alpha) 

#This is irellevant as the the following section that performs a TSNE on the corellation is very clear and avoids confounding due to with high numbers

# TSNEmat <- TSNEdf %>%
#   select(-Sim, -alpha) %>%
#   as.matrix()
# 
# 
# TsneOut1 <-TSNEmat %>%  
#   Rtsne(verbose = TRUE, eta = 1, max_iter = 5000, perplexity = 50) 
# 
# TsneOut2 <-TSNEmat %>%  
#  Rtsne(verbose = TRUE, eta = 1, max_iter = 5000, perplexity = 200) #high seperation of alpha level
# 
# #Plot the TSNE graph
# tsne_plot <- data.frame(x1 = TsneOut1$Y[,1], 
#                         y1 = TsneOut1$Y[,2],
#                         x2 = TsneOut2$Y[,1], 
#                         y2 = TsneOut2$Y[,2]) %>%
#   bind_cols(key)
# 
# ggplot(tsne_plot) + geom_point(aes(x=x1, y=y1, color=alpha))+ 
#    theme(legend.position="none")
# 
# ggplot(tsne_plot) + geom_point(aes(x=x2, y=y2, color=alpha))+ 
#     scale_colour_brewer(palette = "Set1")
# 
# ggplot(tsne_plot) + geom_point(aes(x=x2, y=y2, color=alpha))+ scale_colour_brewer(palette = "Set1")
```

Corellation TSNSE
```{r}

TSNEcormat <- TSNEmat %>% t %>% cor()

dups <-duplicated(TSNEcormat) 

key2 <- key[!dups,]

TsnecorOut1 <-TSNEcormat[!dups,] %>%  
  Rtsne(verbose = TRUE, eta = 1, max_iter = 5000, perplexity = 50, check_duplicates = FALSE) 

tsne_corplot <- data.frame(x1 = TsnecorOut2$Y[,1], 
                        y1 = TsnecorOut2$Y[,2]) %>%
  bind_cols(key2)

ggplot(tsne_corplot) + geom_point(aes(x=x1, y=y1, color= alpha))+ 
     theme(legend.position="none")+
  ggtitle("Low dimensional similarity of the the Edge Round removal\n corellation between all Simulations")
ggsave(file.path(FiguresFolder, "TSNEcor.pdf"))
```


Make random forest classifier

```{r}

trainset <- createDataPartition(key$alpha, p = .75, list = FALSE)

ClassDict <- data_frame(alpha = unique(key$alpha)) %>%
  mutate(ID = 1:nrow(.))

key2 <- key %>% left_join(., ClassDict)

datasetTrain <- bind_cols(select(key2, ID), as_tibble(TSNEcormat)) %>% as.matrix()

rf_ranger_default <- ranger(data = datasetTrain[trainset,],
                              num.trees = 500,
                              mtry = 500,
                              dependent.variable.name = "ID", 
                              num.threads = 7, 
                              classification = TRUE)
  



Out<- predict(rf_ranger_default , data = datasetTrain[-trainset,], type = "response", predict.all = F)
confusionMatrix(Out$predictions, datasetTrain[-trainset,1])

```



```{r}

list.files(PLwd, patter = "(alpha)|(Real)")

setwd(PLwd)
setwd("./alpha_value_105")

Removeddf <- list.files() %>% map_df(~{
 file <- .x
  print(file)
  read_rds(file ) %>%
  RoundRemoved()  %>%
    mutate(Sim = gsub(".rds", "",file))
  
  
  }
) %>%
  group_by(Sim) %>%
  mutate(RoundRemoved = ifelse(is.na(RoundRemoved), max(RoundRemoved), RoundRemoved))

Removeddf2 <- Removeddf %>%
  spread(., key = Sim, value = RoundRemoved)



setwd("/home/jonno/BigHeat")

list.files(pattern = ".R$") %>%
  walk(~{source(.x)})


test2 <- Removeddf2 %>%
  select(-Edges) %>% t %>% cor()

test3 <- orderedheat(test2, simMat = T, mid =0.4)
test3

NL <- read_rds("Simulation_ID_1.rds" ) %>%
  RoundRemoved()
  
NLmat1 <- rep(NL$RoundRemoved, each = length(NL$RoundRemoved)) 

NLmat2 <- rep(NL$RoundRemoved, times = length(NL$RoundRemoved))

NLmat3 <- matrix(as.integer(NLmat1 == NLmat2), nrow=nrow(NL))


gtest <-graph_from_adjacency_matrix(NLmat3) %>%
  simplify() %>% delete.vertices(., degree(.)==0)


plot(gtest)

```


#Analyse results


#Tweaking the package
The below code is used to tweak the R package, add to the documentation etc, etc

```{r}
library(devtools)
library(roxygen2)
setwd( "/home/jonno/PowerGridNetworking")
document()
setwd("/home/jonno")
install("PowerGridNetworking")
library(PowerGridNetworking)

```


```{r}
setwd("/home/jonno")

install("PowerGridNetworking")

```

